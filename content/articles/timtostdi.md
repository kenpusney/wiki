---
title: There's more than 1 SQL to do it
date: 2025-08-07
---

# 做事情的SQL不止一种

最近在准备测试数据的时候遇到了这么一个需求，需要生成 n 个随机的不超过指定区间的连续范围。这如果是在普通的编程语言里，也就是简单的循环 / 递归 / mapfold 简单的糊就OK了。但是考虑到这涉及到数据库的操作，所以我准备使用SQL来直接搞定。

先说一下这个需求，所谓随机的不超过指定区间的范围，我们假设这个区间大小是100，个数（n）是 10，大概就是会生成 10 个从 0 开始的随机递增数字，数字之间的差值是 100 左右，这样就形成了 (0, n1) (n1, n2), (n2, n3) ... 十个连续的范围。

举个例子，比如第一个数是 42，第二个数是 114，那这两个数就是符合预期的。但是如果第三个数突然变成了 514，结果就超出预期了（514-114 远大于 100）。

因为之前恰好使用过 `generate_series` 这个函数（你可以把它理解成 SQL 版的 Python `range`），所以随机生成一个序列比较简单。接下来就是让两者之间满足差值了。我的一个想法是，先把他搞成递增序列，在每个数字前面加上 n * 100，然后再跟自己连接（join）相互错开一行，这样就能拿到钱后顺序了。

结合公共表表达式（Common Table Expression，CTE），很容易拼凑出以下代码。

看起来非常直观，我就不过多解释具体的细节了。

不过这段代码有相当明显的问题。因为生成的序列会先乘以 100 以后再附加一个随机数，这确实保证了递增，但是会出现诸如 (810, 919) 这种范围超过 100 的奇怪情况。

另外这个case when看起来实在是太脏了。如果按照使用的 SQL 特性数量来算工资的话，那我肯定会选用这一版，CTE，case when 和 left join，该用的都用上了。

那么换个思路，既然我们都用了CTE了，能不能用递归来生成随机数，让 SQL 窗口来自动帮我们求和呢？

不得不说这样看起来整洁了很多。还炫技一般地用了窗口函数。除了 sum 那两行看起来几乎完全重复以外，整体挑不出什么毛病了。

我把这段发给朋友看了一眼，他会给我了一串无语符号。

“你都用了递归了，还多做一步 sum 干嘛呢。”

以下是他发过来的版本：

