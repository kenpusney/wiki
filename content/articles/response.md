- 刚看到你也回了这个提问，就着这个回答补充一下。
  
  
  
  首先回答下你的问题，Java/JavaScript的里的final/const只是标注这个identifier不可以rebind，并非真正的constness。
  
  const a = {};
  a.b = 1; // valid
  a = 2 // invalid
  其次，对于pointer来说，本身也就有 const T* 和 T* const 的区别。
  
  const int x = 1;
  const int* ref = &x;
  const int* const cref = &x;
  ref++; // valid
  cref++; // invalid
  至于你说，std::vector<const std::string> a 不能写 a[0] = x 的问题，那不是 const 的锅，而是标准库对于容器的限制。标准库里的要求也是 std::vector must have a non-const, non-volatile value_type ，换句话说这个类型在目前标准库里的实现都不存在（仅以gcc15.2实现为准，C++17对于vector值类型的最低要求是 Erasable，但是也提到了有些操作也会有更严格的要求）。
  
  接下来就对于你上文的疑问分别解答一下吧：
  
  在C/C++中，表面上是深度不可变。但事实上，只是其中一个引用不可变而已。
  这段代码里面，你只是声明了一个 const reference，那只有这个 reference 不可变，完全是符合预期的，任何通过 p 去访问那段内存的行为都必须要符合 const 的要求。你无法通过一个间接的引用来去限制一段内存是否可变——更何况也基本没啥编程语言可以做到这点。
  
  
  
  const是修饰变量还是修饰类型？
  这就要看你认为的 constness 是什么。是运行时的 .rdata 只读数据段（比如C++的字符串字面量），还是 C++ 这种修饰类型来保证 const 类型的数据不可变，还是像 Java/JS 那样不能 rebind。还是更进一步地如zig的 comptime const 或者 C++ constexpr 一样表示编译期数据。
  
  
  
  C++里没有能不能rebind这个问题，引用是直接限制死了不能，指针是为了兼容C，而自定义类型的赋值运算是可重载的，行为由用户自己定义，也可以= delete 干掉这一操作了。
  
  用var/let区分不可变有什么问题？
  这点上我跟你想法一样，更不用说隔壁 JS 的 let 是拿来声明可变变量的。
  
  
  
  不可变是否能提高运行性能？
  隔壁 stackoverflow 都能搜到答案。stackoverflow.com/quest
  
  constexpr 不是拿来做编译优化的，是进行编译期计算的。这部分操作其实还是你作为程序员通过编译器的能力来手动优化，自动优化是更后面阶段的事情了。
  
  正常代码给编译器留下的优化余地不多。
  随便翻的Rfx的一篇回答：（知乎排版有些问题，可以直接跳过去看原回答）
  
  例如说，一个C/C++源码层面上的函数调用，实际实现会由若干小东西构成：对参数列表里的实际参数的表达式逐一求值将实际参数的值根据调用约定传递到指定的目标位置上（如果需要的话）查找目标函数的具体位置调用目标函数，将控制跳转到目标函数的入口处进入目标函数里执行目标函数根据调用约定将返回值传递到指定的目标位置上从目标函数返回，控制跳转回到调用者的一侧如果编译器有足够信息确定目标函数是谁，能够对目标函数内联的话，那么上述步骤中(3)、(4)、(6)、(7)就都不需要了；然后如果目标函数是空函数，那么(5)就是空的；
  
  作者：RednaxelaFX
  链接：zhihu.com/question/6216
  来源：知乎
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  不说别的平台了，五六年前的时候知乎这方面的讨论都非常多，怎么又突然出现“正常代码给编译器留下的优化余地不多了”这种奇妙想法了。 Engineering a Compiler 都出到第三版（2022）了啊明明。
  
  
  
  C++里面有很多后门行为。mutable变量和const_cast这两个机制的存在，导致虚假const。
  这就是我在我的回答中提到的，你不知道程序员什么时候会想要可变这个操作。C++在兼容C的基础上很多地方都得用这玩意儿开洞，那如果你不需要考虑兼容一个上古编程语言，其实是可以甩掉这个包袱的。
  
  
  
  不同类型变量的可变性需求分析
  第1点，如果出现了初始化依赖或者需要延迟初始化（lazy initialization），你全局不可变怎么解决呢？可选的思路是把初始化什么的都交给一个托管的框架，那大概率会得到一个C# ，或者实现了Project Valhalla的Java。
  
  
  
  第2点，C++里的 const 有一个点是，非 const 类型为了兼容 C 是可以不初始化的，但是 const 类型必须要初始化。这是C++里有 const 局部变量的一个好处，其他的嘛，参考上面那个stackoverflow的回答。
  
  
  
  第3.2点，“需要明确清楚是否被修改” 交给编译器去判断，然后再去标记被调用方。因为除非你给到对方的是 .rdata 段的数据，对方改了会导致 segment fault，否则总有任何脏办法在你明确标注是只读的情况下修改你的数据。
  
  
  
  第5点，如果你确实泛型类型需要使用到 const 某类型，完全可以decay或者remove_cv以后再往上塞修饰符，参考 iterator_traits 的操作。这种时候远比考虑在泛型参数上用可变还是不可变来的好，约束是接口提供者提前设计好的，不用用户操心。
  
  
  
  另外 C++ 模版只是模版，与其他编程语言的泛型类型差别还挺多的，轻易不要胡乱模仿。
  
  
  
  第 6 点，C++有引用捕获，当然这个跟constness没太大关系，只是提一句。这样就能做到在闭包里改变上层对象的值。Java虽然有effectively final限制，但也可以通过捕获一个长度为1的数组的方式，在闭包里改变上层对象的内容——这个也是听 Rfx 大佬说过的实践。
  
  
  
  所以还是保持我在我回答里那个 minimum mutability 的观点。也即不区分 const 和 mutable，不允许 rebind，引用必须初始化，不支持除赋值以外的的其他改变内存值的操作。不过这只是设计思路，最近还在糊type checker，要等成型以后才能做更深入的验证。
  
  
  
  以上。