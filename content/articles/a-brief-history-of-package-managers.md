---
title: 包管理漫谈（I）
draft: true
---

应Tison菊苣邀请，聊一下集中式包管理的一些相关问题。但是当我考虑怎么展开的时候，结合我早期规划的一个选题，发现这件事情如果要简单说，可能罗列一下数据就完事儿了。但要详细了说，因为其涉及到了不同功能、不同平台、不同的组织形式和不同的分发形式，加上与日常用户和专业人员都息息相关，所以能扯得很远。于是我想不如直接展开细聊一下，与包管理相关的一切。

通常我们提到包管理，主要会涉及两种形式。一种是作为操作系统提供的管理其上应用软件的工具，比如Debian平台的apt、macOS上的brew和Windows上的winget，以及大家手机上的各种应用商店；另外一种，则是不同编程平台用来进行打包和依赖管理的工具，比如 npm、maven 和 vcpkg。尽管这两种形态区别非常明显，但在一定程度上也有相交融的部分，比如：
- 红帽系yum的各种 `*-devel` 包，其实是对应的开发组件（承担了编程平台的包管理功能），
- vcpkg/conan会安装对应的运行时动态链接库（承担了应用程序的包管理功能），
- USTC的镜像站既有各大Linux发行版的仓库镜像，也有各种编程平台的仓库镜像。

今天的第一部分我们就从应用程序的包管理聊起。

蛮荒时代是没有包管理的概念的，软件和库的分发靠的都是简单的复制传播。即便是到了21世纪的头十年，在App Store的概念还没有深入人心的时候，软件的数字分发也是靠在某些网站上的下载链接。但其实，软件包的概念很早就有了。Windows平台上的Windows Installer早就随着Windows 2000打包发布了，也进而诞生了知名的msi软件包。

为什么软件非要打包发布呢。这就不得不提一下动态链接机制。通常来说，一个简单的应用程序只要被构建出来，就能复制到任意同平台的机器上使用。但是随着应用软件的复杂度增加，这种纯静态构建的应用程序已经无法满足要求了。因为如果所有功能都集成在一个可执行文件里面，整个加载过程可能会无限长，甚至直接搞爆你的内存。所以通常一些不怎么常用或者可以共享的部分，会做成动态链接库，直到需要的时候再按需加载。再加上随着桌面应用的娱乐性提升，应用程序所需要的资源文件也越来越多，越来越复杂，也就需要独立到应用程序之外进行管理。这样一个完整的应用程序就不只是一个可执行文件了，还要包括他所需的动态链接库、资源文件、配置数据等。对于这种场景，微软就搞了套cab（Cabinet）格式来打包和压缩这些文件，并附带好必要的元数据，成为前面提到的msi软件包。

但是Windows平台的开放性高得离谱，所以那个年代的软件包真正能用上Windows Installer的只是很少的一部分，剩下的要么会选择商用版的InstallShield，免费的Inno Setup，或者开源的NSIS。甚至WinRAR也有个神奇的功能，把压缩包生成为自动释放的.exe格式（但是还是拦不住WinRAR.rar）。

但是在自由软件界，就是另外一条路了。因为当年他们远没有Windows这么丰富的生态，以及近乎无下限的开放性和兼容性。古早的unix哲学是靠管道来组合应用程序，但这对于桌面应用和服务器应用来说就是个大问题了，所以也不得不大量引入动态链接库来完善功能。Unix祖传的文件组织形式导致了很多动态库是集中管理并且共享的，所以每个平台都有个独特的版本依赖组成的有向无环图。

早期的Linux发行版会包含多张CD/DVD。其中除了安装操作系统的核心的那张之外，剩下的都是专门放置了各种预构建的软件包。当年并没有那么高效可用的中央仓库和遍布全球的镜像，你所需要的软件，要么是使用预构建的，要么是自己下载源码构建。但是后者既要求用户的专业性，有需要有对这套软件有着细致地了解：因为为了成功构建软件，你还要准备好构建工具以及对应的依赖。为了比较好的控制预编译软件的依赖关系和封装格式，debian系和红帽系分别推出了dpkg和rpm。他们既是安装工具，也是专属格式的软件打包工具。而进一步地，开始出现了集中式的软件包仓库，和分散在全球的镜像网络。dpkg和rpm的增强版，apt和yum出现了。他们一方面拓展了包管理器的可用范围，通过中央仓库控制软件版本的升级；但另一方面，因为软件版本依赖的传染性，导致有时候你不得不面临某些奇怪的版本冲突问题。

早些年看到过这么一个定理，已经找不到出处了，但准确地道出了当时的痛点：任何时候你在当前系统上找到的Python都不是你想要的版本。我愿称它为Python版本测不准定理，这个定理所道出的问题直到诸如nvm和pyenv之类的环境管理工具出现，才有了一定缓解。

为什么Windows平台没这个问题呢。因为Windows没有集中的二进制库中心。虽然Windows和System32文件夹也会作为动态链接库的查找目录，但大部分软件还是会选择自带对应的库。比如你在Debian上用apt安装Inkscape，会自动帮你安装或者升级系统的Python和libgtk这些依赖，而在Windows上，这个软件的安装包会自带一套Python运行时和GTK所需的动态链接库，跟你系统全局的自用九成新Python完全互不干扰。这种分发模式导致Windows下的某些库散布的遍地都是（比如`msvcp*.dll`和`qt?webkit?.dll`），但同样的也让“绿色”（免安装）软件成为了可能。自由软件世界再次（上一次即通过管道协作的古早Unix哲学时期）大规模接受这个设定，应该是Golang之类的纯静态构建的二进制文件流行之后的事情了。比如kubectl，比如helm，这些命令行工具本质上就是个可执行文件。当然了，这些东西与unix时代的工具不同，单独并不能做任何事情，不得不依赖背后的kubernetes集群才能实现特定的功能。

当然了，这就导致了一个严重的问题，就是大部分平台都有成熟的包管理器、中央仓库和全球镜像的时候，Windows的包管理器就直接缺位了。这一点直到后来的chocolatey和winget的出现才补齐。在这过程中虽然也出现了Microsoft Store，但由于总所周知的微软在后桌面时代的失利，这个功能半残的软件商店并没有起到什么作用。目前的winget和Microsoft Store在一定程度上是互通的，好歹是比其他平台稍微有亮点的地方。

在资源和动态库的组织上，后来的移动平台也都采用了Windows的类似设定。比如iOS和Android，他们的App都是运行在特定的沙箱环境里的，只有系统提供的接口，比如Foundation framework或者Android API，否则基本没有任何可以共享的部分。这种情况下所分发的App就不再需要复杂的依赖关系了，只挑系统版本。于是就能愉快的形成“App —— 应用商店”这么一套高效的分发组合。应用开发者是开心的，应用平台也是开心的，不开心的就是消费者。因为这样操作的结果就是每个App占用的空间都急剧膨胀，毕竟为了展示效果往App里塞一个虚幻引擎的操作都能干得出来。自由软件世界也出现了类似设定的AppImage这种打包格式。因为带宽、内存和存储空间和IO效率已经不再像当年那样捉襟见肘，能够无痛享受软件带来的丰富体验反倒是更重要的。

服务端应用也呈现了类似的趋势。虽然这一直都是软件开发的大头，但因为容器化的流行，大部分服务端应用也被打包成为摆脱任何依赖可以直接运行的容器。与沙箱化的桌面和移动应用类似，容器之间也是相互隔离的，也有中央仓库控制版本和分发。而在打包成容器之前，不同的服务端应用在实现平台对应也有着一套复杂的包管理生态，我将在下一篇中跟大家细聊。

