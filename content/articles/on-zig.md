# 说说 Zig

就我也不知道怎么地，最近一周重度使用了一下Zig语言糊了点东西。大概是因为看到某些群里有人非要展示什么Monadic style，就准备上手试一试这玩意儿。

老早就听说Zig的时候，跟他还会一起被提及的就是V，这俩一个对标Rust，一个对标Go。不过从目前的热度看来V语言已经差不多凉透了，Zig反倒是有愈发流行的趋势。

大约三年前(!)的时候我写过一篇梗文，指出 OCaml 作为另外一个缝合怪完全可以看成是 Better C++。毕竟就高阶抽象来看，很多东西 OCaml 比 C++ 都要野得很，不过相对应地其继承自 ML 那边的血脉导致了并没有太多的能力来扩展诸如编译期计算的部分。

Zig 整体的感觉就跟 OCaml 完全背着来了。

## 编译期计算

早期的 C++ 所谓的编译期特性也就仅限于来自 C 的过程宏和花式的模板元编程。这两个特性因为本身语言和计算能力限制的原因，并不能实现非常多的花活，哪怕是一个简单的编译期计算斐波那契数都要堆一大堆的 boilerplate code。

这件事情到了 D 和后来的 C++ 版本里有了改善，也进一步有了一个新的概念 CTFE （Compile-Time Function Evaluation）。其中关键的思路就是，编译期既然能够解析和理解代码的语义，那给他塞个运行时直接去执行并不是个很困难的问题，无非是选择什么时候来干这种事情。D 语言会根据一系列的context来判断是否进行CTFE， C++ 则是加入了 `constexpr` 和 `consteval`。Zig 则是兼两者之长，某些场景下会自动判断，并且你也可以主动通过 comptime 关键字来触发。

## Polymorphism

前面为什么会看到有人整花活搞什么Monadic呢，因为我刚说过，Zig跟OCaml几乎是对着来的，大部分的高级抽象完全被抛弃了。Zig 在语言层面直接提供支持的只有参数化多态而完全抛弃了 ad-hoc 和子类型多态。一个例子就是标准库里的 Allocator 都是要自己主动维护 vtable 的。同时也有人给出了“实现接口效果的四种写法”这种茴香豆操作。在全世界同行几乎都在花式玩抽象的现在，你很难想象这是2020年代会出现的编程语言。

但是，Zig 高就高在，编译期这个时候可以做的事情是很多的。本来 Zig 的类型就是作为某种值而存在的，既然有编译期计算，那也就可以通过类型作为函数参数和返回值来达成的参数化多态。同时很多东西都能进一步往编译期推，所以某个地方你指定了 某个变量/参数为 anytype 同时又尝试调用了一个好像不存在的成员，只要你给定的值能满足了这个调用的签名，那这一切就都是合法的。

当然这些检查会尽可能地提前到编译期，以至于你可以放心地去用这些看上去近乎动态语言的特性。

## 动态？

以上就是除了 tagged union 以外我所能给出的全部褒奖了。因为接下来就是抛弃掉高阶抽象以后带来的各种奇怪行为。

Zig 是要手动管理资源的，不要说垃圾回收，连 RAII 都没给你提供。这也因此导致了其在动态性上几乎做不了什么事情。整个标准库都几乎需要你手动指定allocator。Zig 在这方面留给的最后的温柔，就是跟 Go 里相似的 defer 关键字。这种纯手动的动态性让匿名函数和闭包在 Zig 里都是想当奢侈的存在。你得用类似 Java 匿名内部类的操作，而且还得想尽办法自己手动去绑定对象。

再剩下的就是草草的一坨了。比如没有个正经的初始化语法所以你不得不手动 `.init` 和 `.deinit`，比如为了偷懒强行要求不能 shadowing （你看我说了吧，完全跟 OCaml 对着来）。最让我难以忍受的是，怎么 2025 年了还有人不做 integer promotion，为什么两个 `u16` 相乘还能 overflow？为什么 `usize` 跟 `isize` 之间不能比较大小？为什么 `u16` 跟 `i16` 之间完全不能四则运算？

一句话总结，Zig 可以玩一玩，严肃的东西暂时还是别直接用。Andrew Kelly 和 Zig 团队很多方面相当克制，很多 Proposal 都被拒绝了，这一定程度上来说是好事儿。毕竟某些核心问题都没解决的情况下强行引入的新特性只会加重向前改进的包袱。
