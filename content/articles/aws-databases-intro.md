# AWS Database Intro

今天由我来给大家介绍一下AWS的数据库产品。

## Scope

考虑到前期的一部份内容也cover了一些相关的分布式和事务处理相关的内容，一个简单的session也很难覆盖比较完整的内容。今天的topic主要cover各种数据库模型、他们各自的优缺点和适用场景，并给出一些本部门在这些产品上的应用案例。对于其他方面的话题，如果大家感兴趣我们可以后续再开一个专题讨论。

## AWS Database Products

首先大家来看一下AWS现有的数据库产品。

左边这张图是AWS官方的分类标签下的内容。相对我们常规提到的数据库其实这里有挺多还没有完全cover。

比如 OpenSearch（以及他的前身 ElasticSearch）也可以看成是一个文档型数据库，再比如 RedShift，AWS的官方文档介绍就是 An Amazon Redshift data warehouse is an enterprise-class relational database query and management system.（RDB(Q)MS）。但是鉴于这两者更多的都是在数据分析领域更擅长一些，是主要进行 OLAP 的。所以被分在了Analytics下。

而分类在 Database 类别下的更多是 OLTP 数据库。

## OLAP vs OLTP

这里我们来讲解一下两个概念，OLAP 和 OLTP。
两个分别是 Online Analytical Processing 和 Online Transactional Processing 的缩写。AP 指的是数据挖掘、商业智能、报表和预测等领域。TP 则是指各种事务型操作，比如记录的创建、更新、删除，以及简单的查询操作。

两者明显的区别就是操作复杂度和规模，OLAP 更多会采用复杂的查询读取大量数据来获得分析结果，而 OLTP 更多是大量的简单读写操作，因此通常应对这两种需求会有不同的产品。

当然还有一些声称能够同时满足这两者的数据库管理系统，他们会把这个特性称为 HTAP （Hybrid Transactional & Analytical Processing）。

2020 年， PingCAP 团队发表了业界第一篇描述分布式 HTAP 数据库实际实现的论文： TiDB : A Raft-based HTAP Database

## AWS Database Products

OK 回到我们话题本身上来。前面提到，今天我们关注的重点是 OLTP 数据库，我们再看一下AWS这个数据库产品列表。

- Aurora / RDS 和 DSQL 是关系型数据库，其中Aurora是RDS的改进版，DSQL更是进一步地做成了Serverless
- DocumentDB 是文档型数据库，兼容MongoDB的协议
- ElastiCache、MemoryDB、DynamoDB 是 KV 数据库。ElastiCache 和 MemoryDB 兼容 Redis / Valkey 的协议
- Keyspace （Cassandra） 是列数据库，兼容 Cassandra 的协议
- Neptune 是图数据库，兼容大部分图查询语言
- Timestream 是时间序列数据库

在十多年以前可能我们面临的并不是这样的情况，那个时候关系型数据库几乎是数据存储的首选方案，早期的AWS也是只有RDS这一项服务。那么是什么原因产生了这么多类型的数据库产品呢？

这事儿我们得从头说起。

## Indexing Card

在数字化存储和检索系统普及之前，主要被广泛应用的数据存储和索引的就是这种“索引卡（Indexing Card）”，家用会拿来记录购物清单、联系信息，商用会保存演示的笔记，学术或者专业的图书索引领域就用这种索引卡来建立索引来方便查找图书、文件和笔记信息。

这样一张卡片就是一个具象化的数据记录的模型。等到数字化以后我们其实就是把整理一张张索引卡的任务变成了操作数据库记录。同样地我们也可以从这张卡片上总结出来一个典型的数据记录包含的信息：

- （卡片右上角）数据对应的识别编号
- （卡片主体）数据对应的具体内容
- 不同类型的数据信息（比如日期）
- 以及对于信息的扩展备注（可以看到卡片上有一些手写的标记内容）

注意红圈标注出来的两个区域，可以说所有数据库的设计都是在对这两块区域做取舍。

这是一个完整的数据记录，那么在数字化时代他对应的是哪些形式呢？

## Flat-file Database

最早的数字化处理当然就是直接复刻这套模型了，也就是平面文件数据库，从文件系统出现到现在都在大规模应用，至今在大家的类Unix系统就能直接找到。

``` shell
➜  ~ cat /etc/passwd
##
# User Database
#
# Note that this file is consulted directly only when the system is running
# in single-user mode.  At other times this information is provided by
# Open Directory.
#
# See the opendirectoryd(8) man page for additional information about
# Open Directory.
##
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
daemon:*:1:1:System Services:/var/root:/usr/bin/false
```

这个文件每一个（使用冒号分割开）的字段对应分别表示

用户名:密码占位符:用户ID:用户组ID:注释信息:家目录:登录shell

这种格式的好处是简单易组织，但缺陷也是很明显的，首先每行一条数据，只能表示简单的数据记录。其次数据的组织模式固定，如果需要增加新的字段（或者列），如果是索引卡的话我可以直接手写，而对于这种文本格式就需要修改其对应的处理程序。所以这个模型更多是用于简易的配置文件或者结构简单的数据记录。而也由于早期的计算机主要是文本用户界面，对应也有一些文本工具来进行建议的查询和处理（比如AWK）以及早期的脚本语言Perl（Practical Extraction and Report Language）。

## Navigational Database

为了表示更复杂的关系，后续发展出来了层级模型和网络模型。这两种模型都是为了更好描述数据记录之间的关系。层级模型很容易理解，就是把数据项按照逻辑上的层级关系进行组织，如一个公司的组织架构，就可以建立一个层级模型来表示。

各位可以看这张图，也是现存在每一台Windows机器上的一个层级模型数据库。前段时间我在chat里也提到过，这就是 Windows 的注册表。

层级模型有个特点是每一子记录都只能有一个父记录，这样所有的数据就组合成了一个类似树状的结构。这种操作也有明显的缺陷，就是只能表示一对多的关系，如果是多对多的对应，就需要使用到网络模型。

层级模型和网络模型都被称作为导航数据模型（Navigational Data Model），因为早期计算机性能限制，这些模型中保存的关系连接一般是直接对应到磁盘上的物理地址。这样的好处是在查找的时候会更快，但问题是如果需要更新模型的结构，就需要完全重建一遍所有的数据。

网络模型所采用的访问模式只有三种

- 通过主键直接访问
- 从记录A通过关系导航到记录B
- 按顺序扫描所有记录

这种方式意味着如果需要访问特定数据需要靠程序代码的逻辑来实现。

## Relational Database

1970年，Edgar Codd（埃德加·科德）就针对网络模型的这些问题进行改进，设计出了关系模型。首先是把数据组织成不同的表（或者关系）用来表示不同类型的实体，每个表包含特定数量的列来记录对应实体的属性，每个表的一个或者多个列作为主键，来唯一表示其中的一条记录，表之间通过主键来进行交叉引用而非通过磁盘物理地址。进而科德设计了一组基于关系代数的运算来进行查询。对于数据的存储结构，科德提出了“规范化”的概念，把一些数据拆分成不同的“表”，来确保每个具体的实体只存储一次，从而节省空间和简化更新操作。

另外由于关系代数是经过严格定义和证明的，而在此之上的很多复杂查询可以通过经过数学证明的优化操作来重写，这样查询优化等操作转为由查询引擎来实现，一定程度上摆脱了对于用户的水平要求 —— 这一点也是科德所希望的，数据库查询语言应该是一个声明式的语言，这样由用户提出需要获取哪些内容，数据库管理系统去执行如何进行扫描、索引、和数据访问的操作。

1974年 ACM Sigmod 组织了一场 Workshop，会议上主要讨论了 CODASYL代表的网络模型 和 科德的关系模型，双方针对一些复杂的业务场景各给出了相关的解决方案，同时也针对性地指出对方的各种问题。以当时的角度来看，关系模型因为需要进行关联关系的计算和连接，整体性能上肯定不如网络模型。

但是时间抹平了一切，计算机系统的性能发展迅速。七八十年代随着使用关系模型实现的数据库（INGRES、System R、Oracle）被商业化应用，以及SQL查询语言的标准化，都反复证明了科德的关系模型的优势。

## Object Database

九十年代，随着面向对象方法的流行，关系模型遇到了新的问题 —— 对象关系阻抗失配（Impedance Mismatch）。因为面向对象的模型与存储在关系数据库中的数据映射存在一定的问题，比如

- 面向对象的模型的数学基础是有向图（图论），而关系模型则是关系代数中的元组和关系（集合论）
- 面向对象倾向于隐藏内部实现，但是为了与数据表的列映射需要公开这些细节
- 面向对象的“继承”模式在关系数据库中不存在
- 面向对象通过引用来关联，关系数据库通过外键
- 对象通常包含其他对象，而关系模型不能嵌套（NewSQL已经部分解决了这个问题）
- 面向对象的操作逻辑是命令式的，而关系模型的操作模式是声明式
- 关系型数据库的执行单位是事务，而通常一个事务远比对象的一个方法更复杂

为了解决这个问题，业界设计出了“对象数据库”和后期的“对象关系映射”框架。

对象数据库短暂的存在了一段时间，一方面是因为他跟编程语言强绑定，另一方面则因为其本身实现上难以实现一些简单的关系模型之上的查询。但对象数据库的一部份遗产形成了后来的文档数据库。

ORM框架一定程度上能够解决上述问题，但同时也带来了另一些痛点：

- 为了实现面向对象操作的灵活性，对应生成的关系表和操作相当复杂，很难通过直接的映射转换成关系表的结构
- 一些简单的业务查询在ORM侧的处理也会加载整个对象模型甚至关联子对象，导致整个查询效率降低
- ORM框架（以 JPA 为例）尝试隐藏关系模型的物理实现细节，难以针对性进行调整和优化

本来想找一个例子的，但搜了一下发现暂时找不到一个合适的使用Hibernate继承的实现，这同时也说明了这东西设计之复杂甚至这么大的一个特性都没有人用。而目前我们能看到的大部分在代码里访问数据库的模式都是事务脚本或者DAO。

至此我们先进行一个小结：

- 数据模型倾向于更加灵活易于拓展
  - 网络模型增加了多对多关联关系
  - 关系模型把数据与物理存储解耦
  - 面向对象的方法用业务对象替代数据对象
- 数据库查询方式倾向于更加用户友好
  - 关系模型引入了声明式查询
  - 面向对象方法把对象语言和模式引入数据建模
- 数据库建模倾向于领域化、业务化，同时尽可能对非技术人员友好
  - 关系查询本身是代数语言，到了SQL变成了领域特定语言


## Database Integration

早期出于成本、可用性等多方面的考虑，通常在一个组织的某项业务中一般只使用一个数据库实例，各种应用程序通过这个数据库实例来进行集成，应用A产生的数据由应用B来读取，分别实现对应功能。

这种共享数据库的模式有不少的缺点。

- 首先满足不同应用的需求，数据库结构必然要设计的复杂一些
- 其次，各种应用之间的数据库操作也需要对应的协调机制
- 另外，不同应用之间的实现方式、结构和性能条件都不相同，难以针对性进行优化

对应的解决方案则是采用“应用数据库”，即每个应用都拥有自己的数据库实例，应用之间通过API接口来进行集成。这样每一个数据库的结构可以由应用团队自己维护，甚至选择何种数据库实现来完成某个功能都是可选的。

一个具体的例子，老系统中统计foo在线的代码是在一个共享库里实现的，通过 count 一个 PostgreSQL 的表。而在新 系统 中，由foo中心（foo-service）来维护foo的数据，对应的foo在线状态和统计也是通过专门接口处理，数据存在 ElastiCache（Redis） 里，避免了对 Postgres 的频繁访问。

我们来看看互联网时代。

## Internet Age

互联网时代的一个特点就是产生了大量而且结构不固定的数据。一方面网络应用逐渐复杂，用户逐渐增多；另一方面因为新兴的需求和应用不断出现重构着已有的模式。关系数据库也遇到了新的挑战。

- 首先是模式化，每个表都是有固定结构的，对于互联网应用来说模式更新，比如新增加或者减少字段是个成本相对昂贵的操作。另外，对于一些简单的数据结构需要额外的建模成本。
- 其次是中心化。关系型数据库在设计和实现上没有特别考虑过水平扩展的场景。而为了应对日益增长的流量，大型互联网应用必须选择分布式化来提升吞吐量。关系型数据库在这方面成为了瓶颈。
- 第三就是去专业化。关系模型是一个通用模型，对于一些专门的问题，比如处理复杂层次对象、复杂关联关系和时间序列数据等缺乏专门优化。

## AWS Database Products

现在我们再来看一下AWS的数据库产品列表，他们分别在一定程度上解决了上述问题。

ElastiCache 和 MemoryDB 是简单的 Key Value 数据库，同时支持丰富的数据结构（比如集合、Hash、有序集等），可以快速高效地实现一些无模式的数据结构操作。

Amazon DocumentDB 和 DynamoDB 是文档型数据库，允许用户直接保存无模式数据，或者一个结构复杂的对象，而不用像关系型数据库一样先创建复杂的Schema。

Keyspace （Cassandra） 是列数据库，从数据的物理存储形式上就与关系型数据库选择了完全不同的结构，因此整体的存储和查询的性能表现也截然不同。

Neptune 是图数据库，可以存储复杂对象关系并通过相应的领域语言快速查询一些关联性操作。

Timestream 是时间序列数据库，对于时间敏感和需要进行时序范围查询的操作进行了特殊优化。

可以看到，从数据结构、存储形式、以及具体到读写和查询的场景都有针对性的设计。

这就回答了我们最开始提出的问题，为什么有这么多数据库产品。接下来我们分别了解一下这些产品。


## Key-Value DB

最基础的自然就是键值数据库了。ElastiCache 和 MemoryDB 都是基于内存的键值数据库。这些数据库的特色就是实时性强，但因为内存并非持久化存储，所以容易丢失。因此更多会作为缓存数据库，或者保存一些应用运行时的会话数据。

ElastiCache 和 MemoryDB 都兼容 Redis，也是键值数据库中最流行的一个实现。Redis并不提供具体的数据建模工具，只是提供了一系列的Command（命令）允许用户操作数据记录。设置某个键的值，更新一个Hash的内容，或者使用Pub/Sub来实现简单的消息队列。

这给了用户足够的自由度，任何能够满足Redis数据结构的内容都可以放进去，再原样取出来，所以你也完全可以把它当成一个大的共享内存空间，同一个服务的所有实例都可以访问同一个Redis数据库来实现服务的无状态化。这也就有了另外一个应用实例，在Redis中实现一个分布式锁，来避免同一服务不同实例之间的竞争。

## DocumentDB 文档数据库

DocumentDB（和 MongoDB）基本的存储结构是文档。文档位于集合中，不同的文档有不同的字段。文档相当于关系数据库中的行，字段相当于关系数据库的列，集合对应的是关系数据库中的表。不过因为
DocumentDB 是无模式的，所以一个集合中的文档并不一定要有特定结构，只要是有效的JSON对象就可以。

比如在系统中，考虑到物联网端上报的数据结构是动态大小，并且有多种不同类型的报文，而每个报文相对之间是独立的。对于系统来说我们只需要把他们看成同一类型的数据存储到一个collection里就可以，不需要关注其在细节上的差异。相关的查询也是根据foo的关键字段来查询，数据库端没有额外的负担。

同样地，对于模型的变更只需要考虑业务代码层面上的后向兼容即可。比如同样类型的数据，新的GB32960-2025标准的数据也可以直接放在同一个集合里，标准所扩展的结构更多的是会在业务逻辑端实现，数据库端只需要按照新的结构存储即可，也没有额外的负担。

DocumentDB支持使用JSON文档来构建查询，同时提供丰富的检索运算符来扩展查询内容。对于复杂的文档也支持嵌套的内容检索，并且在不处理整个文档的情况下查询其内部属性。

## DynamoDB

相对来说另外一个文档型数据库DynamoDB在模型上的限制要更多一些。但正是因为他是AWS上原生的NoSQL数据库，其天生基于云的特性使其运维复杂度远低于其他数据库。

每个DynamoDB实例就是一张表。DynamoDB的表主要以键值为基础，一组主键关联一个Item。Item中包含扁平或者简单的嵌套结构。每个DynamoDB的表都需要定义主键，其中包含一个Partition Key和一个可选的Sort Key。查询主要围绕着主键或者二级索引（Secondary Index）来进行，而不像 DocumentDB 那样可以对任意属性进行查询。

但也正是因为这些限制，让DynamoDB的无服务架构可以做到毫秒级延迟的高并发读写，同时支持无限制扩容和跨区域一致性。

后面几个类型的数据库我们并没有响应的应用，所以我就简单介绍一下。

## Column-Oriented Database

Keyspace 是一个兼容 Cassandra 的列数据库。相较于其他NoSQL的无模式的特点，列数据库还是需要对应的建模来进行列和列族的设计。

列数据库与关系型数据库最大的区别就在于，列数据库的存储方式是按照列来存，这样同样类型的数据可以连续存放在一起，对其的查询操作也就可以连续进行。因为本身CPU和内存对于连续数据都有响应的优化，这种操作也就可以充份利用CPU Cache来提升查询效率。

而列数据库又通常采用LSM树作为存储引擎，其写入效率相对基于B+树的关系数据库。

另外列数据库在实现上采用的是原生的分布式架构，通过Partition Key和一致性哈希来进行分片和扩展操作。

