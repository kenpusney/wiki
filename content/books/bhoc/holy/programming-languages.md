---
title: 圣战简史：编程语言篇
date: 2020-09-14
draft: true
---

跟编辑器一样，编程语言也是个生产力工具。这俩另外的一个共同点就是，都在圣战的核心。

编程语言是站队分派别的主要方式，并且因为这一点的存在，也就成了各种编程语言背后的势力来控制程序员的主要途径。你真别不相信，大部分时候借用编程语言来宣扬某些东西是最能让对应的开发者群体买账的方法，后面我们会看到一些例子。

另外一方面，编程语言是某种编程思维的具体实现。一门编程语言必然满足一种或者多种编程范式，编程范式直观地限定了设计代码时所考虑的重点和解决方案，但不同的范式之间只有适用场景的不同，没有显然的优劣之分。反倒是一些人因为了解顺序问题，总会把后来者当成是更高级的。但殊不知对应的思想远在60年代就已经出现、成熟，恰是有些人借助这种编程语言的宗教煽动性，形成一系列的高低贵贱的观点。

同样的编程语言也是如此，只有适用于某些场景的编程语言，没有“最好”的编程语言（<del>PHP除外</del>）。我在2014年得到过一个“编程语言定律”：一切编程语言都是Domain Specific的。这一点至今没变。没有一个通用的编程语言可以实现一切。

这一点我们在最初的编程语言里面就能看出端倪。最早的编程语言都是解决各种领域问题的，从他们的名字上就能看出来：

- IPL: **I**nformation **P**rocessing **L**anguage 信息处理语言
- Fortran: **FOR**mula **TRAN**slation 公式翻译
- LISP: **LIS**t **P**rocessing 列表处理
- COBOL: **CO**mmon **B**usiness-**O**riented **L**anguage 通用业务语言
- Algol: **ALGO**rithm **L**anguage 算法语言
- SNOBOL: **S**tri**N**g **O**riented and sym**BO**lic **L**anguage 面向字符串和符号的语言
- Simula: **SIMULA**tion 模拟
- Modula: a langauge for **MODULA**r multiprogramming 用于多模块化编程的语言
- Perl: **P**ractical **E**xtraction and **R**eporting **L**anguage 实用提取和报表语言 
- FP: **F**unctional **P**rogramming 函数式语言

所以我们看到Fortran拿来做科学计算、LISP拿来做符号计算、Algol用来描述算法、Perl用来处理文本和数据，他们都有着光明的前途。

这个光明的前途，也是一步步走出来的。

# 一

在开始聊编程语言之前，先说明一下，我们的scope是计算机科学领域。毕竟在“programming”表示“编程”之前，另有别的意思，比如 Linear Programming。

而且远在编程语言出现在之前，也需要用于描述步骤和执行步骤的方式，比如古希腊数学家欧几里得用来记录著名的欧几里得算法（用于计算两个数字的最大公约数），也是用定义完善的规则来描述的执行步骤，而后人只需要通过在《几何原本》里面描述的步骤自然也就能利用该算法求最大公约数。

这个过程常被人忽视而直接进入到了下一步：机器出现，需要指令来控制机器的执行，于是才出现了编程语言。但在没有机器之前，理解和执行指令的是人。比如下面一个老梗：

> 妻子让做程序员的丈夫去超市买两个面包，并说：“如果有鸡蛋的话，就买六个”。
> 
> 结果不一会，丈夫带着六个面包回来了。妻子奇怪地问：“你怎么买了六个面包？”，丈夫回答说：“你不是让我有鸡蛋的话就买六个吗？我看超市里有鸡蛋，所以就买了六个”

熟悉编程的人很容易看懂这个笑话的梗，而也正是这个笑话明显能看出作为“指令”和“执行”这两部分之间沟通的重要性：与人沟通尚且如此，与机器沟通自然也就需要更明确的指令。中国人发明了算盘，可以拿来做计算，但去操作的依然是操纵算盘的人。直到19世纪Charles Babbage在提花机的基础之上进一步设计了**分析机**（Analytical Engine），才有了可以通过指令自动解决问题的“机器”，与之一起出现的，是第一位程序员Ada Lovelace和最早的“计算机程序”。

当然了，在Babbage的时代，完全没有指令集的概念，所以他给出的是一些操作性的示例。而根据John Walker提供的模拟器的还原，提供了一系列标准的符号化指令用于简化程序的设计，这些指令是跟Babbage的打孔卡相对应的。如下是一段求阶乘的程序：

```
N0 6
N1 1
N2 1
×
L1
L0
S1
–
L0
L2
S0
L2
L0
CB?11
```

`CB`在这里指的是Conditional Branching，是巴比奇的一大创新。有了这个操作整个分析机就可以进行重复和分支执行代码。

遗憾的分析机和更早的差分机都没能在巴比奇的有生之年被建造出来。而且因为一些原因，早期的电子计算机如Havard Mark I和ENIAC（埃尼阿克）并没有直接继承巴比奇的设计，而是重复踩了很多坑。

不过在威廉·吉布森的小说《差分机》的设定下，差分机和分析机得到了重生，Ada也成发表了对应设定背景的“哥德尔不完备性定理”。尽管现实世界没有直接受太多的影响，但因为《差分机》带来的蒸汽朋克浪潮还是进入了主流文化圈。

而至于Ada，70年代以后我们还会遇到她的。

# 二

时间进入20世纪。

大卫希尔伯特在世纪初提出了23个世纪问题，而与计算机科学息息相关的就是希尔伯特第十问题，“可判定性”。30年代，Alonzo Church和他卓越的学生Alan Turing分别给出了自己的计算模型：λ演算和图灵机。

当然距离主流计算机产业意识到这之间的联系还有一段时间，我们就不拓展这个话题了。

电子计算机出现后的很长一段时间内，依然都是在延续巴比奇的模型：通过指令控制机器。之所以没有成形的编程语言出现，一方面早期计算机的执行效率低，转换和执行编程语言的速度远低于直接解释执行指令。

John Mauchly在1949年设计了Short Code，用于把数学形式的表达式转译成机器指令，这样既方便理解，也方便编写。但其问题在于，每一次执行的时候都有一个前置的转换到机器指令的过程，导致Short Code要比机器指令慢50倍之多。

Alick Glenie在50年代早期实现的Autocode是最早的编译型编程语言之一。与Shortcode运行时在翻译的过程不同，Autocode程序会被预先编译成机器指令，运行时直接执行机器指令就好。而根据Alick的编译器说明书，生成的程序比原始的机器代码只慢“不到10%”。

---

1952年，IBM发布了其第一台商用机，IBM 701。

之后的1953年，29岁的费城小伙John Backus设计了Speedcoding。跟Autocode和Short Code类似，是一个用高级代码编写IBM 701程序的高级编程语言。

Backus在他的论文中提到，有了Speedcoding以后，花费需要几周才能完成的701程序，只要几个小时就能编写完成。由此虽然带来了比较长的运行时间，但却能节省掉更高的人力成本。

这不仅仅是工作安排上的一个平衡问题，也是后来诞生的软件工程学领域的一个核心问题——总是有人追求靠不断投入人力、拉长时间来解决问题，而不是追求更高效的工作方式。

Backus的这次成功经验直接促成了下一个重要的编程语言的诞生。

# 三

1953年末，John Backus向IBM提交了一个建议，为构建IBM 704开发一个更实用的编程语言。基本的想法就是简化数学表达式的输入方式。1954年11月份，IBM Mathematical Formula Translaing System规范草案编写完成。随后的1956年10月，FORTRAN的说明文档出现，1957年4月，第一个FORTRAN编译器正式交付。这是第一个正式商用的编程语言，也是第一个优化型编译器：毕竟对于当时的使用者来说，还是希望所使用的高级语言生成的程序，要能够达到跟手写汇编一样的效率。

FORTRAN团队的一些程序员是国际象棋棋手，因为觉得他们的思维逻辑性更强，于是就被选中作为IBM的雇员。后来的John Backus在接受采访时说，大部分的工作源自于其偷懒的想法：因为不喜欢写程序，所以在给IBM 701写导弹轨迹计算程序的时候，就尝试搞一个可以更方便写程序的程序。而这个思路，也就演变成了随后的FORTRAN。

