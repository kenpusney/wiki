# 圣战捡屎 A Shit of Holy War

## 缘起

你知道程序员是个了不得的群体，这群人其实是最宗教，最容易被煽动和感染的群体之一。每个人都多多少少的带着无数种信仰写出一行行的代码，这些信仰指导着他们的工作，学习和仅有的一部分娱乐，包括且不限于，建立鄙视链、划定群体和引发圣战。

我曾试图分析过为什么程序员们对圣战这么热衷，后面发现最终都会落地到宗教性上。任何工具或者系统，作为程序员日常的一部分，都因为习惯、崇尚的哲学和各种奇怪的原因，被作为了圣战的战场：编辑器、操作系统、程序设计语言、不同的编码习惯、不同的工程流派等等。

我个人其实很反感这种感觉，所以对任何圣战相关的话题我都会保持一个中立的态度（当然除非是为了活跃气氛吼一句，“PHP是最好的编程语言”）。毕竟，所有的工具，只有被好好使用才是有用的工具，这种很大程度上出于自身的倾向形成的圣战，只能说明个人的惰性。不过，另外值得提的一点，战争有时候是能够推进科技进步的。程序员的圣战也一样。虽然可能花在互怼上的时间一定程度上影响了效率，但相互争论之后的结果一定是某一方或者两方尝试去提升自己的实力：进而把工具、系统或者理论变得更好。

这也是为什么我想到要写简史的原因。能让我们进步的事情是值得记录和赞扬的，虽然他们本质上可能并不是为了进步。

## 从最基本的工具说起

曾经在跟同事一起pair的时候，他进到一个运行中的docker容器里面，发现找不到任何一款趁手的编辑器来编辑配置文件了。因为要知道为了尽量保证容器清量我们肯定是让容器里的东西尽可能的越少越好。这个时候就看到他有点慌，毕竟这种如果不这样做把编辑好的文件复制到内网再放到容器里这样的过程是非常折腾的。

大部分人遇到这种问题第一个反应也是，`apt install vim`。作为黄金时代编辑器的胜出者，Vim已经是dominant了。绝大多数情况下在连接远程服务器的时候最趁手的编辑工具一定就是它，这也是当年一个Vim党在向我安利Vim的时候的理由。

其实解决这个问题根本用不到安装编辑器这么麻烦，毕竟我们现在使用的是终端模拟器，比上古时代的终端好用了不知道多少倍。Linux Shell又是基于字符流的，所以用标准输入或者heredoc可以轻松实现修改文件内容的动作。只是各位基本功和认知不到位，或者没有见识过上古时代的工具，一直出于惯性地以为工具就是这个样子才行，造成的错觉罢了。

你看，了解历史多重要。

回到话题，编辑器这个东西，在上古时代就是个难题。毕竟在上古时代，“文件”这个概念可能都不存在。

### 打孔卡

这是最早的编程工具了。

如果大家有看过图灵的传记的话肯定知道最早的那个计算机是用什么来做输入的。一个个的转盘转到指定的位置，来表示输入，然后等状态输出的转盘转到特定的位置来表现表示输出。

打孔卡也一样，通过孔的状态来去区分0和1。这样有个好处就是可以通过这张卡的数量来动态的控制输入输出。但是同样还是有问题，当你的打孔卡有地方出错的时候，修改起来十分麻烦，至少某一段打孔卡你要完全重新编辑。

直到后面电子媒介产生，大家可以通过使用特定的编码来存储信息，才有了进一步使用电子输入设备编辑文本和代码的可能性。

### TECO

我们看一下上古时代的几个经典编辑器。

第一个能称道的就是TECO（Text Editor & Corrector）。它首先是一个面向字符的编辑器，其次是一个用于文本处理的编程语言。

TECO是PDP-1时代的产品。在TECO之前，有一个叫“昂贵的打字机”（Expensive Typewriter），可以接入IBM的打字机作为输入，在PDP-1上进行文字处理。这个名字的后半部分来自于另外一个早期的编辑器“巨型打字机”（Colossal Typewriter），作者是LISP之父，约翰麦卡锡；前半部分嘛，就是因为PDP-1比起打字机来贵得多了。

TECO的整体思路是为了提升PDP-1的利用率，所以在设计思路上与直接通过控制台来编辑文档的思路不同。TECO会接受两个磁带的输入，一个是源文本磁带，另外一个是更正磁带，TECO会读取更正磁带上的指令来即时修改源文本磁带上的内容。这样作为操作人员只需要实时输入指令就能实现即时编辑文档了。

所以更正磁带其实就相当于是用来做文本处理的程序，因为TECO实现的太过于复杂，以至于这些命令组合起来是图灵完全的。所以，TECO完全可以作为一个编程语言来用。

TECO的命令以及后面加入的宏足够强大，以至于后面把编辑宏（Edit MACroS）集合起来打包发布了一个应用，EMACS。

## ed 和 ex

真的等 Emacs 系出现并成熟都已经是后话了。

1969 年是个丰收的年份。AT&T 贝尔实验室的 Ken Thompson 实现了第一版的 Unix 操作系统，其中包含了三个关键的组件：汇编器、编辑器和 shell。ed 就是其中的编辑器，关键组件之一。

ed 很经典的地方在于实现了对正则表达式的支持，同时也是一个基于命令的面向行的编辑器。相较于 TECO 的复杂，ed 更多的是灵活和直接，可以直接从标准输入读入编辑命令，然后把改动反应并写入到文件中。

但相对应地也有一个很致命的缺点，就是不能实时预览编辑，只有通过特定的命令（`,l`）来查看结果。（毕竟根据 Unix 设计哲学，一个程序只做一件事情，查看文档内容应该去找 cat 或者 more。）于是也就被冠以了“对用户最不友好的编辑器”的名头。

后面自然就因为这个缺点被其他编辑器给替代了，我们虽然依然能够在系统中看到他的身影（毕竟按照 POSIX 标准，这是系统必备的程序之一），也几乎没人在用了。可在早期，这个编辑器配合 Unix shell，能够完成非常强大的自动化功能。这也逐渐催生了基于流的编辑器变种，sed。而另外一个常用的非交互式应用，也因为 ed 中的正则表达式引擎被制造出来，成为了现在搜索常用的 grep（`g/re/p`，Globally match RegExp and Print）。

另外，ed 中的大部分命令，也因为接下来的这个程序被传承了下来。

1970 年以后 Unix 在西方各个高校传播，英国 Queen Mary College 的 George Coulouris 在开发了一个 ed 的增强版，em，来更好的通过视频终端展示和做编辑。后面在 Berkeley 访问的时候，Coulouris 把他的程序展示给了 Bill Joy，后者在做了一些相应的改动之后，实现了一个扩展版，ex（EXtended）。后来这个应用就进了伯克利软件发行版（Berkeley Software Distribution），成为了知名的 BSD 系统的一部分。再之后就被连同它的“可视化版”一起加入了 POSIX 标准。

哦这个可视化版就是 vi（ex visual mode）。

后来 vi 又被分化出了一个改进版（Vi IMproved），就是基本常规桌面类 Unix 操作系统里面必备的 vim 了。

从 ed 到 vim，里面的命令几乎是一脉相承的。插入是 i，追加是 a，替换是 s，写入是 w，退出是 q。

我依稀记得有段时间还比较热衷于编辑器圣战的时候，有人非要跟我争论说 Emacs 才是最符合 Unix 哲学的，然而事实上作为一个加了扩展之后臃肿不堪的半操作系统，Emacs 既没有纯正的 Unix 血统，又实在不符合只做一件事的 Unix 哲学，所以，这方面反倒是 vi 更胜一筹。

### Edit MACroS

### VI

### 图形化的时代

### 开源时代



## xxx是最好的编程语言

### 还是得提一下打孔卡

### 汇编语言

### 编程语言世代

### 毒瘤

### Goto 被认为是有害的（EWD）

### FP

