<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript">
        if (location.href.endsWith("index.html")) {
            location.href = location.href.substring(0, location.href.length - "index.html".length);
        }
    </script>
    
    <title>关于函数的一切</title>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
        media="(prefers-color-scheme: light)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/dracula.min.css"
        media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
        media="(prefers-color-scheme: no-preference)">
    <style type="text/css">
        body {
            width: 60%;
            margin: 0 auto;
            padding: 2em;
            font-family: 'Segoe UI',
                "Microsoft Yahei Light",
                "San Francisco",
                "Ping Fang SC",
                "Roboto",
                "Noto Sans CJK",
                Tahoma, Geneva, Verdana, sans-serif;
        }

        span.field {
            display: inline-block;
            font-weight: bolder;
            font-size: smaller;
        }

        pre {
            max-width: 90%;
            overflow-x: scroll;
            padding: 1em;
            border-radius: 5px;
        }

        a {
            text-decoration: none;
            color: cornflowerblue;
        }

        a:visited {
            color: cornflowerblue;
        }

        a:hover {
            color: darkgray;
        }

        a.disabled-link {
            color: lightcoral;
            text-decoration: line-through;
        }

        nav,
        nav ul {
            display: inline-block;
        }

        .tags ul,
        footer ul {
            padding: 0;
            display: inline;
        }

        header h1 {
            display: inline-block;
            min-width: 320px;
            max-width: 50%;
            width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: auto;
        }

        @media screen and (max-width: 1200px) {
            body {
                width: 90%;
                max-width: 720px;
                padding: 0;
                margin: 1em auto;
            }

            header h1 {
                max-width: 90%;
                width: 90%;
            }
        }

        nav li,
        .tags li,
        footer li {
            display: inline;
            border-right: 1px solid darkgray;
            padding: 0 1em;
        }

        nav li:last-child,
        .tags li:last-child,
        footer li:last-child {
            border: none;
        }

        .post-list h3 {
            margin: 0.3em 0;
        }

        blockquote {
            margin: 0.5em;
            border: 1px dotted darkgrey;
            border-radius: 0.5em;
            padding: 0 1em;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #090810;
                color: floralwhite;
                opacity: 0.83;
            }

            pre {
                background-color: #282a36;
            }
        }
    </style>
</head>

<body>

    <header>
        
        <h1 title="关于函数的一切">关于函数的一切</h1>
        
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/articles">Articles</a></li>
                <li><a href="/about">About</a></li>
            </ul>
        </nav>
        <hr>
        <span class="field">Author: <a href="/about">KimmyLeo</a></span>
        
    </header>
    <article>
        <p>本文源自于我在2012～2013年写的 Meta Functions 系列文章，以及知乎专栏的《map四种》。通过细致地讲解和练习函数相关的内容来让大家更细致地认识函数、闭包、延迟计算、流和解释器。</p>
<p>后期根据情况看是否会加入类型检查和模式匹配相关的内容。</p>
<h2 id="函数">函数</h2>
<p>我们先来实现一个简单的函数，比如斐波那契数列的定义。</p>
<pre><code><span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(n)</span></span> = fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span> = <span class="hljs-number">1</span></code></pre>
<p>如果你熟悉递归，可以很容易根据上面的递归定义把fib函数实现了（code 1-1）：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(n) {
    if (n === 0 || n === 1) {
        <span class="hljs-keyword">return</span> <span class="hljs-type">1</span>;
    }
    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);
}</code></pre>
<p>我们来看求fib(10)的时候的展开图：</p>
<pre><code>fib(<span class="hljs-number">10</span>) =&gt;
fib(<span class="hljs-number">9</span>) + fib(<span class="hljs-number">8</span>) =&gt;
fib(<span class="hljs-number">8</span>) + fib(<span class="hljs-number">7</span>) + fib(<span class="hljs-number">7</span>) + fib(<span class="hljs-number">6</span>) =&gt;
fib(<span class="hljs-number">7</span>) + fib(<span class="hljs-number">6</span>) + fib(<span class="hljs-number">6</span>) + fib(<span class="hljs-number">5</span>) + fib(<span class="hljs-number">6</span>) + fib(<span class="hljs-number">5</span>) + fib(<span class="hljs-number">5</span>) + fib(<span class="hljs-number">4</span>) =&gt;
.....</code></pre>
<p>最后展开会是一个深度为10节点非常多的递归树。</p>
<p>在我的电脑上，计算fib(30)已经需要等待一段时间，明显感觉到延迟了。</p>
<h3 id="尾递归">尾递归</h3>
<p>对于这个操作，实际可以用另外一个办法来简化，就是通过尾递归，把计算的操作合并到尾调用的参数求值中去。
（code 1-2）</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(n, a = 1, b = 1) {
    if (n == 0) {
        <span class="hljs-keyword">return</span> <span class="hljs-type">a</span>;
    }
    <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>, b, a + b);
}</code></pre>
<p>这个时候的fib(10)的展开：</p>
<pre><code><span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">13</span>, <span class="hljs-number">21</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">34</span>, <span class="hljs-number">55</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>)</span></span> =&gt;
<span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">89</span>, <span class="hljs-number">144</span>)</span></span> =&gt;
<span class="hljs-number">89</span></code></pre>
<p>所有的计算通过两个额外的参数来累加，而不是通过反复的递归调用展开，这个时候只有递归层次的深度，就连计算fib(100)也都只需要递归调用100次就好，能够立即返回结果。</p>
<p>如果你曾经用循环的方式实现过斐波那契，那要想导出这个尾递归版本其实并不困难：
（code 1-3）</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        [a, b] = [b, a+b];
    }
    <span class="hljs-keyword">return</span> a;
}</code></pre>
<p>好的，首先我们把循环倒过来写：
（code 1-4）</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n; i &gt; <span class="hljs-number">0</span>; i--) {
        [a, b] = [b, a+b];
    }
    <span class="hljs-keyword">return</span> a;
}</code></pre>
<p>把for改成死循环：
（code 1-5）</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> i = n;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> a;
        }
        [i, a, b] = [i<span class="hljs-number">-1</span>, b, a+b];
    }
}</code></pre>
<p>改一下参数和变量名：
（code 1-6）</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span><span class="hljs-params">(n, a = 1, b = 1)</span> </span>{
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> a;
        }
        [n, a, b] = [n<span class="hljs-number">-1</span>, b, a+b];
    }
}</code></pre>
<p>while(true) 里面的内容，跟为递归版的结构几乎一模一样，而这里直接改到参数的赋值，就可以一步替换为尾递归。</p>
<p>你可以对比code 1-2和code 1-6的内容。现实其实通常是反过来的，就是会通常是我们通过尾递归的方式写成1-2的样子，然后再由编译器优化成1-6。这样的结果是能够省掉函数传参和压栈的过程，算是一步提效明显的优化，对时间（额外的压栈和传参操作）和空间（调用栈）的开销都能节省很多，还能避免不必要的爆栈（Stack Overflow）风险。</p>
<h3 id="练习">练习</h3>
<p>请实现另外一个常用递归函数阶乘（factorial）的直接递归版和尾递归版。阶乘函数的定义如下：</p>
<pre><code>factorial(<span class="hljs-name">n</span>) = n * factorial(<span class="hljs-name">n</span> - <span class="hljs-number">1</span>)
factorial(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span></code></pre>
<h2 id="函数进阶">函数进阶</h2>
<p>我们上一节简单实现了一个函数，那么现在来认真地回顾考虑这么一个问题，函数到底是什么？</p>
<p>其实很简单，函数就是这么一个结构，你给他一个输入，他返回给你一个输出。而其由输入得到输出的过程，是你可以定义的。</p>
<p>这其实是一个非常广义的抽象，可以拿来类比各种东西，比如一个生产流水线也可以这么抽象地看，原材料作为输入，产品作为输出；而这个流水线的每一个节点又都是有自己的输入和输出。</p>
<p>于是我们可以看到函数的另外一个特征：可组合（Composable）。</p>
<h3 id="可组合性">可组合性</h3>
<p>比如我们定义一个函数，去求一个数组排序后的结果：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sorted</span>(<span class="hljs-params"><span class="hljs-keyword">array</span></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>.slice().sort();
}</code></pre>
<p>然后再定义一个函数，来求一个数组反转之后的结果：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> reversed(<span class="hljs-keyword">array</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>.<span class="hljs-keyword">slice</span>().reverse();
}</code></pre>
<p>那如果我们要求一个数组的降序排序的结果，就直接组合这两个调用就好：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort_reversed</span>(<span class="hljs-params"><span class="hljs-keyword">array</span></span>) </span>{
    <span class="hljs-keyword">return</span> reversed(sorted(<span class="hljs-keyword">array</span>));
} </code></pre>
<p>正式函数的这种可组合性，让我们能通过定义有限的正交算子，来组合出无限的操作。</p>
<blockquote>
<p>有些人可能会说，这个直接做成Array的方法，也是能够做成链式调用来组合的：</p>
<pre><code class="language-javascript"><span class="hljs-built_in">Array</span>.prototype.sorted = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.slice().sort();
}

<span class="hljs-built_in">Array</span>.prototype.reversed() = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.slice().reverse();
}</code></pre>
<p>实际这两种做法本质上是同一件事情。有些编程语言（比如D语言）中，<code>x.f(y)</code> 与 <code>f(x, y)</code> 是等价操作，实现的这种转换叫做<strong>统一函数调用语法</strong>（Uniform Function Call Syntax）。</p>
</blockquote>
<h3 id="函数对象">函数对象</h3>
<p>回到上面的排序函数。</p>
<p>JavaScript有一个问题，就是排序默认是用的文本序，对数字也是如此，也就是说，111是会排在12前面的，而JavaScript的Array.prototype.sort函数会让我们传递一个匿名函数进去来作为排序的比较器（Comparator），达到对数值做排序的目的。</p>
<p>这个比较器就是一个函数对象。</p>
<pre><code class="language-js">[<span class="hljs-number">1</span>, <span class="hljs-number">111</span>, <span class="hljs-number">12</span>]<span class="hljs-string">.sort((x,</span> <span class="hljs-string">y)</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">x</span> <span class="hljs-bullet">-</span> <span class="hljs-string">y)</span>
<span class="hljs-string">//</span> <span class="hljs-string">=&gt;</span> [<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">111</span>]</code></pre>
<p>函数对象，又叫匿名函数，在某些语境下面也叫lambda表达式（因其源自于lambda演算）。一个函数对象是可以赋值给某个变量、作为参数传递的；或者说，函数对象，是第一类值（first class value）。</p>
<p>比如上文中的 <code>(x, y) =&gt; x - y</code>。</p>
<h3 id="闭包">闭包</h3>
<p>既然函数是第一类值，那么我们也就能有方式来构造他了。</p>
<p>通常一个函数在传递过程中不只是作为一个独立的单位存在，还会包括一些上下文，这样组合起来的一个结构就叫闭包。</p>
<p>比如，我们定义以下函数，会返回一个函数对象，而这个函数对象每次调用都会累加一次，行为表现像是一个计数器：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params"></span>) </span>{
    let count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> count ++;
}</code></pre>
<p>这里返回的函数对象，其实就捕获了makeCounter函数中的变量count，并一直持有。在任何时候我们操作这个函数，都会改变这个变量的值。这个时候的变量可以被成为upvalue（因为是上层（upper）函数中的值（value））。</p>
<p>这样看起来似乎毫无意义。</p>
<p>我们来看一个深入的结构：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pair</span><span class="hljs-params">(left, right)</span> </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-keyword">fn</span>) =&gt; <span class="hljs-title">fn</span><span class="hljs-params">(left, right)</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">left</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">return</span> a;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">right</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">return</span> b;
}

<span class="hljs-keyword">let</span> p = pair(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

p(left) <span class="hljs-comment">// =&gt; 1;</span>
p(right) <span class="hljs-comment">// =&gt; 2;</span></code></pre>
<p>pair给我们构造了一个对象（这个时候已经不仅仅限于函数对象了），然后我们通过另外定义的两个函数来去访问这个对象的内部结构，而这个实际的内部结构并没有直接暴露给我们。</p>
<p>上面这段话你看到了哪些关键的东西？</p>
<ul>
<li><strong>对象</strong>：pair构造了一个有序对，这个对象可以由我们后续定义的方法来操作和访问</li>
<li><strong>方法</strong>：left和right两个函数本身并没有实际的意义，与pair对象绑定以后，可以利用pair中的数据来实现预期的行为</li>
<li><strong>封装</strong>：pair的内部结构在构造时确定，无法在外部获取和改变内部结构，只能通过定义pair的方法来处理</li>
</ul>
<p>在只有“函数”这个构造的情况下我们也能做这些事情。甚至在一些编程语言（比如Java/C++）里面，函数对象就是通过结构/类+特定的方法来实现的，也就只有这样他们才能做捕获形成闭包。</p>
<h2 id="数据抽象">数据抽象</h2>
<h3 id="可变性">可变性</h3>
<p>我们知道OO的一个特色是可变性来描述状态，闭包在这里也完全可以实现。当然需要借助一些额外的结构。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutablePair</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> x;
        [a, b, x] = fn(a, b)
        <span class="hljs-keyword">return</span> x;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLeft</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> [a, b, a];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRight</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> [a, b, b];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setLeft</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> [value, b, a]
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setRight</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> [a, value, b]
}

<span class="hljs-keyword">let</span> mp = mutablePair(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

mp(getLeft); <span class="hljs-comment">// 1</span>
mp(getRight); <span class="hljs-comment">// 2</span>
mp(setLeft(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 1</span>
mp(getLeft); <span class="hljs-comment">// 5</span></code></pre>
<p>其实可以看到，mp接受的每个函数都是(a, b) =&gt; [a, b, x] 这种形式。这样就是能够给传递函数充分地信息来获取结构，然后生成充分足够地信息来更新mp闭包的内部。如果我们再简化一点，把a和b作为一个对象比如this或者self来看，mp接受的每个函数变成了 (self) =&gt; result。其中对self的改变也包括在内。</p>
<p>这其实就是大部分编程语言的面向对象的“方法”的实现机制，都会给这些方法绑定一个this或者self变量，让方法内部可控制。</p>
<p>你看，就这么简单。</p>
<h3 id="练习-1">练习</h3>
<ol>
<li><p>给mutablePair实现一个方法，可以交换pair左右两边的值。</p>
</li>
<li><p>有没有更简单地只用函数来实现mutablePair的方式？</p>
</li>
</ol>
<h3 id="生成器">生成器</h3>
<p>我们回想一下上一个场景中的计数器，其实是一个非常有用的结构。</p>
<p>比如我们希望得到斐波那契数列，但又不希望提前获取这所有内容的时候：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibGenerator</span>(<span class="hljs-params"></span>) </span>{
    let n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fib(n++)
}</code></pre>
<p>实际，你看，进一步地我们可以抽象出来这样一个结构，就叫生成器，根据你提供的函数再来求一个结果：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generator</span>(<span class="hljs-params">fn</span>) </span>{
    let n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> () =&gt; <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">n++</span>)</span>;
}

y = <span class="hljs-built_in">generator</span>(fib);

y(); <span class="hljs-comment">// 1</span>
y(); <span class="hljs-comment">// 1</span>
y(); <span class="hljs-comment">// 2</span>
y(); <span class="hljs-comment">// 3</span>
y(); <span class="hljs-comment">// 5</span>
y(); <span class="hljs-comment">// 8</span></code></pre>
<p>然后，不知道你是否发现了这么一个问题，就是，这个生成器只能前向迭代，也就是说，没法倒带的。</p>
<p>来我们看一下怎么实现：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bidirectionalGenerator</span><span class="hljs-params">(fn)</span> </span>{
    <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> (direct) =&gt; {
        <span class="hljs-keyword">let</span> result;
        [n, result] = direct(n, <span class="hljs-function"><span class="hljs-keyword">fn</span>)</span>;
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backward</span><span class="hljs-params">(n, fn)</span> </span>{
    <span class="hljs-keyword">return</span> [n<span class="hljs-number">-1</span>, <span class="hljs-function"><span class="hljs-keyword">fn</span><span class="hljs-params">(n<span class="hljs-number">-1</span>)</span>]</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forward</span><span class="hljs-params">(n, fn)</span> </span>{
    <span class="hljs-keyword">return</span> [n+<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">fn</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>]</span>;
}

<span class="hljs-keyword">let</span> bg = bidirectionalGenerator(fib);
bg(forward); <span class="hljs-comment">// 1</span>
bg(forward); <span class="hljs-comment">// 2</span>
bg(forward); <span class="hljs-comment">// 3</span>
bg(forward); <span class="hljs-comment">// 5</span>
bg(forward); <span class="hljs-comment">// 8</span>
bg(backward); <span class="hljs-comment">// 5</span>
bg(backward); <span class="hljs-comment">// 3</span>
bg(forward); <span class="hljs-comment">// 5</span>
bg(forward); <span class="hljs-comment">// 8</span></code></pre>
<h3 id="练习-2">练习</h3>
<p>给generator加上范围限制。</p>

        

    </article>
    <!-- <div>
        <h5>See Also</h5>
        <ul>
            <li><a href="/about">About Me</a></li>
        </ul>
    </div> -->
    <span class="field">创建时间：2020-07-17</span>
    <span class="field">最近更新时间：2020-09-07</span>
    <hr>
    <footer>
        <ul>
            <li><a href="/about">关于我</a></li>
            <li><a href="/sitemap.xml">站点地图</a></li>
            <li><a href="/rss.xml">RSS</a></li>
            <li>Copyright &copy; KimmyLeo</li>
        </ul>
    </footer>
    <script type="text/javascript">
        document.querySelectorAll(".disabled-link").forEach(el => el.addEventListener("click", (e) => {
            alert("链接页面不存在！");
            e.preventDefault();
        }))
    </script>
</body>

</html>