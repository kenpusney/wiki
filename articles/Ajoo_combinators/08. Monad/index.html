<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/javascript">
    if (location.href.endsWith("index.html")) {
      location.href = location.href.substring(0, location.href.length - "index.html".length);
    }
  </script>
  
    <title>
      论面向组合子程序设计方法 之八 monad
    </title>
    

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
          media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/dracula.min.css"
          media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
          media="(prefers-color-scheme: no-preference)">
        <style type="text/css">
          body {
            width: 60%;
            margin: 0 auto;
            padding: 2em;
            font-family: 'Segoe UI',
              "Microsoft Yahei Light",
              "San Francisco",
              "Ping Fang SC",
              "Roboto",
              "Noto Sans CJK",
              Tahoma, Geneva, Verdana, sans-serif;
          }

          p>img {
            margin: 0 auto;
            display: block;
            max-width: 80%;
          }

          span.field {
            display: inline-block;
            font-weight: bolder;
            font-size: smaller;
          }

          pre {
            max-width: 90%;
            overflow-x: scroll;
            padding: 1em;
            border-radius: 5px;
          }

          a {
            text-decoration: none;
            color: cornflowerblue;
          }

          a:visited {
            color: cornflowerblue;
          }

          a:hover {
            color: darkgray;
          }

          a.disabled-link {
            color: lightcoral;
            text-decoration: line-through;
          }

          nav,
          nav ul {
            display: inline-block;
          }

          .tags ul,
          footer ul {
            padding: 0;
            display: inline;
          }

          header h1 {
            display: inline-block;
            min-width: 320px;
            max-width: 50%;
            width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: auto;
          }

          @media screen and (max-width: 1200px) {
            body {
              width: 90%;
              max-width: 720px;
              padding: 0;
              margin: 1em auto;
            }

            header h1 {
              max-width: 90%;
              width: 90%;
            }
          }

          nav li,
          .tags li,
          footer li {
            display: inline;
            border-right: 1px solid darkgray;
            padding: 0 1em;
          }

          nav li:last-child,
          .tags li:last-child,
          footer li:last-child {
            border: none;
          }

          .post-list h3 {
            margin: 0.3em 0;
          }

          blockquote {
            margin: 0.5em;
            border: 1px dotted darkgrey;
            border-radius: 0.5em;
            padding: 0 1em;
          }

          div.image-description {
            text-align: center;
            color: gray;
            font-size: smaller;
          }

          @media (prefers-color-scheme: dark) {
            body {
              background-color: #090810;
              color: floralwhite;
              opacity: 0.83;
            }

            pre {
              background-color: #282a36;
            }
          }
        </style>
        <script>
          var _hmt = _hmt || [];
          (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?d06710df49879016f95c45042560225e";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
          })();
          </script>
</head>

<body>

  <header>
    
      <h1 title="论面向组合子程序设计方法 之八 monad">
        论面向组合子程序设计方法 之八 monad
      </h1>
      
          <nav>
            <ul>
              <li><a href="/">Home</a></li>
              <li><a href="/articles">Articles</a></li>
              <li><a href="/about">About</a></li>
            </ul>
          </nav>
          <hr>
          <span class="field">Author: <a href="/about">KimmyLeo</a></span>
          
  </header>
  <article>
    <p>仍然是先用oo把轮廓划出来，我们需要建模一个接口来围绕它进行组合。 </p>
<p>因为本文是关于co的论述，那么这个接口怎样分析出来的就暂时忽略掉了： </p>
<p>java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dependency</span></span>{ 
  <span class="hljs-function">Object <span class="hljs-title">getArgument</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, Class type)</span></span>; 
  <span class="hljs-function">Class <span class="hljs-title">verifyArgument</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, Class type)</span></span>; 
  <span class="hljs-function">Object <span class="hljs-title">getProperty</span><span class="hljs-params">(Object key, Class type)</span></span>; 
  <span class="hljs-function">Class <span class="hljs-title">verifyProperty</span><span class="hljs-params">(Object key, Class type)</span></span>; 
}
</code></pre>
<p>这个Dependency接口由每个不同的组件调用，来解决依赖。如果解析失败，则抛出异常。此处，我们暂时忽略异常这个细节。 </p>
<p>getArgument负责解析一个函数参数，组件告诉Dependency对象，我需要给第3个参数，类型为String的解析依赖。于是就调用 
getArgument(2, String.class)。 </p>
<p>getProperty负责解析一个用某个key来标识的属性。比如一个javabean的property。 </p>
<p>那两个verify是只取得解析到的那个符合要求的组件类型，但是并不实际创建对象。 </p>
<p>然后是Component接口。这里，为了名字简短，我们不用ComponentAdapter这么恶长的名字，直接就是Component好了。 </p>
<p>java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-function">Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>; 
  <span class="hljs-function">Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>; 
  <span class="hljs-function">Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>; 
}
</code></pre>
<p>getType()用来返回这个Component生成的对象的类型。 
create用来创建这个对象。 
verify用来保证这个对象可以被创建。 </p>
<p>至于容器接口，再简单不过了。我们都知道pico不过是个hash table，yan的容器也差不多，虽然多几个getComponentOfType()的方法，但是大体上就是一个hash table。 </p>
<p>java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Container</span></span>{ 
  <span class="hljs-function">Component <span class="hljs-title">getComponent</span><span class="hljs-params">(Object key)</span></span>; 
  <span class="hljs-function">Component <span class="hljs-title">getComponentOfType</span><span class="hljs-params">(Class type)</span></span>; 
} 
</code></pre>
<p>好了。oo完毕。下面来co。 </p>
<p>首先，最简单的Component是什么？什么也不干，直接返回一个值。 
java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object v; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-keyword">return</span> v==<span class="hljs-keyword">null</span>?<span class="hljs-keyword">null</span>:v.getClass(); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> v; 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> getType(); 
  } 
} 
</code></pre>
<p>稍微难啃点的，是构造函数和工厂方法。这两个都会调用Dependency的getArgument()来取得自己需要的参数实例。 
实际上，java的reflection api里面的Method和Constructor还是有很多相似点的。 
为了抽取共性，我们定义一个新的接口，叫做Function: </p>
<p>java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span></span>{ 
  <span class="hljs-function">Class <span class="hljs-title">getReturnType</span><span class="hljs-params">()</span></span>; 
  Class[] getParameterTypes(); 
  <span class="hljs-function">Object <span class="hljs-title">call</span><span class="hljs-params">(Object[] args)</span></span>; 
}
</code></pre>
<p>这里，我就不展现把Method和Constructor匹配为Function的代码了，因为应该一目了然。 
我们只要知道我们现在可以有三个函数产生Function对象： </p>
<p>java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Functions</span></span>{ 
  <span class="hljs-function"><span class="hljs-keyword">static</span> Function <span class="hljs-title">ctor</span><span class="hljs-params">(Constructor ctor)</span></span>; 
  <span class="hljs-function"><span class="hljs-keyword">static</span> Function <span class="hljs-title">method</span><span class="hljs-params">(Object obj, Method mtd)</span></span>; 
  <span class="hljs-function"><span class="hljs-keyword">static</span> Function <span class="hljs-title">static_method</span><span class="hljs-params">(Class type, Method mtd)</span></span>; 
}
</code></pre>
<p>当然，还有一些辅助函数， 
比如： 
java代码: </p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">static</span> Function <span class="hljs-title">ctor</span><span class="hljs-params">(Class type)</span></span>;
</code></pre>
<p>然后是FunctionComponent。 
java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Function f; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-keyword">return</span> f.getReturnType(); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">final</span> Class[] types = f.getParameterTypes(); 
    <span class="hljs-keyword">final</span> Object[] args = <span class="hljs-keyword">new</span> Object[types.length]; 
    foreach(t:types){ 
      args[i] = dep.getArgument(i, t); 
    } 
    <span class="hljs-keyword">return</span> f.call(args); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">final</span> Class[] types = f.getParameterTypes(); 
    foreach(t:types){ 
      Class arg_type = dep.verifyArgument(i, t); 
      checkTypeMatch(types[i], arg_type); 
    } 
    <span class="hljs-keyword">return</span> f.getReturnType(); 
  } 
} 
</code></pre>
<p>然后一个基本的component应该是java bean的setter了，对应pico的SetterInjectionComponentAdapter，也对应spring的bean。 
java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanComponent</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class type; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-keyword">return</span> type; 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    Object r = createInstance(); 
    setJavaBeans(r,dep); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    ... 
  } 
}
</code></pre>
<p>具体的实现我省略了很多。因为会调用java.beans的api，并且会有一些caching优化的考虑，但是思路上很清楚，就是对每个property调用getProperty()就是了。 </p>
<p>好，最基本的就这么几个了（其实，bean component并不是最基本的，后面我们会看到）。 </p>
<p>下面看看都有些什么组合规则。 </p>
<p>1。手工指定某个参数。 
java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithArgument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Component parent; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pos; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Component arg; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-keyword">return</span> parent.getType(); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> parent.create(withArg(dep)); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> parent.verify(withArg(dep)); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">private</span> Dependency <span class="hljs-title">withArg</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dependency(){ 
      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getArgument</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, Class type)</span></span>{ 
        <span class="hljs-keyword">if</span>(i==pos){ 
          checkTypeMatch(type, arg); 
          <span class="hljs-keyword">return</span> arg.create(dep); 
        } 
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dep.getArgument(i, type); 
      } 
    } 
    ... 
  } 
} 
</code></pre>
<p>好，通过decorate这个Dependency对象，我们得到了手工制定某个参数的能力。 
这里，我们对参数仍然用Component，而不是一个简单的Object作为这个参数的值，是因为参数本身也可能需要创建，它的依赖关系也可能需要在Dependency对象中解析。如果参数不需要创建，那么，你尽可以用ValueComponent来包装一下。 </p>
<p>2。手工指定property的值。跟上面的代码非常类似，就是重载了getProperty()和verifyProperty()。 
java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithProperty</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Component parent; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object key; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Component prop; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-keyword">return</span> parent.getType(); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> parent.create(withProp(dep)); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> parent.verify(withProp(dep)); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">private</span> Dependency <span class="hljs-title">withProp</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dependency(){ 
      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProperty</span><span class="hljs-params">(Object k, Class type)</span></span>{ 
        <span class="hljs-keyword">if</span>(k.equals(key)){ 
          checkTypeMatch(type, prop); 
          <span class="hljs-keyword">return</span> prop.create(dep); 
        } 
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dep.getProperty(k, type); 
      } 
    } 
    ... 
  } 
} 
</code></pre>
<p>3。和很多组合子一样，map是一个相当有用的组合规则。它负责把一个Component返回的对象作一下额外的处理，transform成另外一个对象。 
java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span></span>{ 
  <span class="hljs-function">Object <span class="hljs-title">map</span><span class="hljs-params">(Object obj)</span></span>; 
}
</code></pre>
<p>java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Component c; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map map; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> map.map(c.create(dep)); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    c.verify(dep); 
    <span class="hljs-keyword">return</span> Object.class; 
  } 
    ... 
} 
</code></pre>
<p>注意，这里，因为我们无法预先知道Map这个接口返回的对象会是什么类型，所以，我们让getType()返回null来标示这是一个动态决定的组件类型。 </p>
<p>4。比map更一般化一点的，是bind动作。所谓bind，也是根据一个Component创建的对象来决定接下来返回什么动作。不同的是，它用这个对象来产生另外一个Component，让这个Component来生成一个新对象。多说无益，让我们看代码： 
java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Binder</span></span>{ 
  <span class="hljs-function">Component <span class="hljs-title">bind</span><span class="hljs-params">(Object obj)</span></span>; 
}
</code></pre>
<p>java代码: </p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>{ 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Component c; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Binder binder; 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">create</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    <span class="hljs-keyword">return</span> binder.bind(c.create(dep)).create(dep); 
  } 
  <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">verify</span><span class="hljs-params">(Dependency dep)</span></span>{ 
    c.verify(dep); 
    <span class="hljs-keyword">return</span> Object.class; 
  } 
    ... 
}
</code></pre>
<p>这个Binder接口看似简单，但是它的存在对整个co都是生死攸关的大事。可以说，如果没有这个Binder, co就基本可以不存在了。 
为什么这么说呢？因为这个binder再加上前面的那个ValueComponent代表了一种非常一般性的计算模型：monad。有一个专门的数学分支：组论，就是研究monad的。 
它虽然不是放之四海皆准的计算模型，比如，有比它更为一般性的Arrow模型。但是，用它几乎可以描述我们一般所遇到的大量问题。 </p>
<p>除了前面的几个基本组合子之外，几乎所有的组合子，如果我们愿意，都可以从这个bind推衍出来。比如上面的map，如果用简洁点的函数式语法来表述的话（原谅我还是忍不住用函数式，java的语法就象一砣一砣屎一样压得我喘不过气来） 
java代码: </p>
<pre><code class="language-haskell"><span class="hljs-title">map</span>(a, f) = bind (a, \x-&gt;value(f(x)));
</code></pre>
<p>这个代码的意思是说，你可以很轻易地把一个Map对象adapt到Binder对象，只要在bind函数里面调用： 
java代码: </p>
<pre><code class="language-java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ValueComponent(map.map(v));
</code></pre>
<p>就行了。 </p>
<p>后面的很多组合子，比如对一个组件生成的对象调用某个方法，设置一些java bean setter，都是从这个bind组合子衍生出来的。 </p>
<p>好了，今天时间紧迫，到此告一段落吧。</p>

      

  </article>
  <!-- <div>
        <h5>See Also</h5>
        <ul>
            <li><a href="/about">About Me</a></li>
        </ul>
    </div> -->
  <span class="field">创建时间：2006-01-13</span>
  <span class="field">最近更新时间：2021-08-30</span>
  <hr>
  <footer>
    <ul>
      <li><a href="/about">关于我</a></li>
      <li><a href="/sitemap.xml">站点地图</a></li>
      <li><a href="/rss.xml">RSS</a></li>
      <li>Copyright &copy; KimmyLeo</li>
    </ul>
  </footer>
  <script type="text/javascript">
    document.querySelectorAll(".disabled-link").forEach(el => el.addEventListener("click", (e) => {
      alert("链接页面不存在！");
      e.preventDefault();
    }));
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script
</body>

</html>
