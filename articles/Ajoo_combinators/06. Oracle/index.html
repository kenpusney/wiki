<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript">
        if (location.href.endsWith("index.html")) {
            location.href = location.href.substring(0, location.href.length - "index.html".length);
        }
    </script>
    
    <title>论面向组合子程序设计方法 之六 oracle</title>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css">
    <style type="text/css">
        body {
            width: 60%;
            margin: 0 auto;
            padding: 2em;
            font-family: 'Segoe UI',
                "Microsoft Yahei Light",
                "San Francisco",
                "Ping Fang SC",
                "Roboto",
                "Noto Sans CJK",
                Tahoma, Geneva, Verdana, sans-serif;
        }

        span.field {
            display: inline-block;
            font-weight: bolder;
            font-size: smaller;
        }

        pre {
            max-width: 90%;
            overflow-x: scroll;
        }

        a {
            text-decoration: none;
            color: cornflowerblue;
        }

        a:visited {
            color: cornflowerblue;
        }

        a:hover {
            color: darkgray;
        }

        a.disabled-link {
            color: lightcoral;
            text-decoration: line-through;
        }

        nav,
        nav ul {
            display: inline-block;
        }

        .tags ul,
        footer ul {
            padding: 0;
            display: inline;
        }

        header h1 {
            display: inline-block;
            min-width: 320px;
            max-width: 50%;
            width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: auto;
        }

        @media screen and (max-width: 1200px) {
            body {
                width: 90%;
                max-width: 720px;
                padding: 0;
                margin: 1em auto;
            }
            header h1 {
                max-width: 90%;
                width: 90%;
            }
        }

        nav li,
        .tags li,
        footer li {
            display: inline;
            border-right: 1px solid black;
            padding: 0 1em;
        }

        nav li:last-child,
        .tags li:last-child,
        footer li:last-child {
            border: none;
        }

        .post-list h3 {
            margin: 0.3em 0;
        }

        blockquote {
            margin: 0.5em;
            width: 100%;
            border: 1px dotted darkgrey;
            border-radius: 0.5em;
            padding: 0 1em;
        }
    </style>
</head>

<body>

    <header>
        
        <h1 title="论面向组合子程序设计方法 之六 oracle">论面向组合子程序设计方法 之六 oracle</h1>
        
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/articles">Articles</a></li>
                <li><a href="/about">About</a></li>
            </ul>
        </nav>
        <hr>
        <span class="field">Author: <a href="/about">KimmyLeo</a></span>
        
    </header>
    <article>
        <p>不少朋友说我的阐述很苍白无力。这让我很苦恼。我确实是拚了命地想把问题说清楚，我也有实际non-trivial的项目经验，怎么就说不明白呢？哎！ </p>
<p>所以，还是不能不多罗嗦一下，希望能够再阐述得明白一点。 </p>
<p>其实，所谓co，有心的朋友也许能够感觉到，它很象是设计一门语言。 
它有顺序/分支，有函数调用，异常处理，基本上一个程序设计语言有的东西它都有了。这些顺序/分支作为语言的基础设施，而一些应对具体需求的原子操作，（比如WriterLogger，比如NeptuneExceptionLogger）则可以看作是语言的扩展或者库。 </p>
<p>只不过，c/c++/java是有编译器来把源代码转化成目标代码。而co的组合子则是利用了宿主语言（比如java）本身的能力来实现各个组合子的语义。可以说，co是在设计一门语言中的语言。 </p>
<p>最近这段时间，流行过一阵LOP（language oriented programming），就是用domain-specific-language来处理一些特定的domain需求。 
为什么会有这种说法呢？还是因为domain的需求多变灵活，不容易琢磨，所以人们发现用一个灵活的语言比用一些功能相对死板的库更容易对付。 
但是dsl的实现不是那么容易的。而co是不是可以说给我们提供了一个相对廉价的创建自己的domain specific language的途径呢? 
我们虽然不能说 
java代码: </p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> level &gt; <span class="hljs-number">1</span> then logger1 <span class="hljs-keyword">else</span> logger2</code></pre>
<p>至少可以退而求其次，写出 
java代码: </p>
<pre><code class="language-java">ignore(<span class="hljs-number">1</span>, logger1, logger2);</code></pre>
<p>当然，这种子语言相比于宿主语言，缺乏调试器的帮助，缺乏编译器的优化，缺乏各种ide的支持，可用性程度是大大不如的。 </p>
<p>但是，它也有它的好处，那就是，不用额外进行一次编译；写出来的东西和宿主语言无缝集成；可以自动利用宿主语言里面的一切设施。等等。 </p>
<p>那么如果把co作为一个语言来考虑，是不是会给我们一些别的启示呢？ </p>
<p>oz曾经质疑，所谓的co，怎样决定基本的组合子？怎么样才知道组合子够用了？ </p>
<p>那么，设计语言的时候，怎么设计基本的语言设施？怎么样知道这个设施是不足，还是太多呢？ 
这是个大话题，语言设计非常有争议性和主观性。但是，也仍然是有些共性的。比如，几乎所有的语言都支持顺序，if/else，递归/循环，函数定义等。相当多我们熟悉的语言还支持异常处理，字符串，整数等。 </p>
<p>我们难道不能从这里借鉴一些东西？如果我们把基本的nop, 顺序，分支作为启动co的基本要求，这算不算是一个可以遵循的guidline呢？ </p>
<p>另外，不同的语言，根据它所面向的领域，还有一些不同的内建操作，比如perl，面向文本处理，所以内建了regexp，而c/c++因为直接面对机器硬件模型，所以提供了指针。 
那么，根据我们的组合子所要面对的应用类型，我们也可以预先定义一些内建的原始组合子，比如那个WriterLogger。 </p>
<p>一般来说，对general purpose的语言，设计的基础设施都是非常”基础“的，基础到几乎不会有什么设施是多余的。同时，也基础到一般人都可以没有什么困难地掌握基本的语法语义。 
那么这些语言用这么有限的聊聊几个设施怎么对应它不可能预见的各种现实中的需求呢？ </p>
<p>我们平时对可以用简单的if-else，顺序，循环就可以做几乎任何我们能想到的事情感到惊讶了吗？对某个语言能否处理复杂的需求担忧了吗？ </p>
<p>为什么没有呢？就在于”组合“的威力。就是那么几个简单的设施，组合起来却可以具有巨大的力量。 </p>
<p>同样，在设计组合子的时候，如果我们遵循这些共性，同时在和具体需求磨合的时候积极改进组合子本身，应该就可以达到一个可以满意的组合子系统。 </p>
<p>说到这里，可能有人问：你不是说组合子系统是脱离需求自己发展的吗？ </p>
<p>这个，怎么说呢？还是说语言。设计一个语言，原则上是设计一些和具体需求没有耦合的基础设施，然后让写具体应用的人组合这些基础设施达到我们语言设计者不可能都预见到的某些具体效果。 
但是，在语言设计和逐渐发展过程中，仍然会从用户（就是程序员）那里得到反馈，什么样的需求是他们需要的，什么样的设施不好用，然后设计者再进行改进。 </p>
<p>一个语言，一般不会是某个具体需求通过划分责任，自顶向下的设计，最后作为这个需求的附属模块被开发出来。更多的情况，是语言的设计者对可能面对的需求有 一个大致了解，并且知道这种可能的需求是变化的，不确定的，于是才会从基本设施开始设计这个语言，最后交付给开发具体应用的人来使用。 </p>
<p>组合子系统也遵循一样的规律。组合子的设计需要来自具体需求的灵感和纠正。但是，基本组合子本身却不能耦合于这些具体需求。 
组合子的设计者应该对可能面对的需求有大致的了解，但是并不需要完整地预测这种多变的需求。 </p>
<p>当然，组合子这种语言中的语言，还有不容易理解的弱点。当组合层次增多，逻辑变得复杂，这个复杂的组合子可不象写在一般的程序设计语言里面的代码那样简明，java繁琐的语法让这种语言中的语言对一些程序员也许就象是神庙里面的神谕一样难以理解，甚至让人望而生畏。 </p>
<p>这一半是因为java本身没有提供对这种高阶逻辑的直接支持，组合的语法相对繁琐。如果用haskell，使用语言提供的do-notation，形式上的复杂程度就没了。 </p>
<p>另一方面，高阶逻辑都是有这种弱点的。 
其实，就算是oo，相比于po，它的多态也是降低可理解性的。 </p>
<p>因此，就象我们也不能在oo中到处override虚函数一样，组合子的使用也要有一定的度，过犹不及。 </p>
<p>好了，没有实际例子的论述已经太长了。肯定已经有人昏昏欲睡了。 </p>
<p>做个调查，我下面的例子有几个选择： </p>
<p>1。简单的predicate。就是一个具有bool is(Object v);方法的接口。 
2。ant的FileSelector。一个predicate的变体。 
3。swing提到的jdbc的action。负责数据库操作的组合子。 
4。yan container的component。负责从任意的构造函数，工厂方法，java bean以及它们的任意组合来产生和注射组件。比pico/spring灵活很多。 
5。neptune的command，负责调用任何ant task以及其它的可能返回一个java对象的函数。是一个一般化了的ant task。</p>
<p>这些东西都是基于组合子的。大家觉得对哪一个更有兴趣呢？我有些拿不定主意哪个更合适。</p>

        

    </article>
    <!-- <div>
        <h5>See Also</h5>
        <ul>
            <li><a href="/about">About Me</a></li>
        </ul>
    </div> -->
    <span class="field">创建时间：2006-01-13</span>
    <span class="field">最近更新时间：2020-08-25</span>
    <hr>
    <footer>
        <ul>
            <li><a href="/about">关于我</a></li>
            <li><a href="/sitemap.xml">站点地图</a></li>
            <li><a href="/rss.xml">RSS</a></li>
            <li>Copyright &copy; KimmyLeo</li>
        </ul>
    </footer>
    <script type="text/javascript">
        document.querySelectorAll(".disabled-link").forEach(el => el.addEventListener("click", (e) => {
            alert("链接页面不存在！");
            e.preventDefault();
        }))
    </script>
</body>

</html>