<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript">
        if (location.href.endsWith("index.html")) {
            location.href = location.href.substring(0, location.href.length - "index.html".length);
        }
    </script>
    
    <title>Java 中的不可变性问题</title>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
        media="(prefers-color-scheme: light)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/dracula.min.css"
        media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
        media="(prefers-color-scheme: no-preference)">
    <style type="text/css">
        body {
            width: 60%;
            margin: 0 auto;
            padding: 2em;
            font-family: 'Segoe UI',
                "Microsoft Yahei Light",
                "San Francisco",
                "Ping Fang SC",
                "Roboto",
                "Noto Sans CJK",
                Tahoma, Geneva, Verdana, sans-serif;
        }

        p > img {
            margin: 0 auto;
            display: block;
            max-width: 80%;
        }

        span.field {
            display: inline-block;
            font-weight: bolder;
            font-size: smaller;
        }

        pre {
            max-width: 90%;
            overflow-x: scroll;
            padding: 1em;
            border-radius: 5px;
        }

        a {
            text-decoration: none;
            color: cornflowerblue;
        }

        a:visited {
            color: cornflowerblue;
        }

        a:hover {
            color: darkgray;
        }

        a.disabled-link {
            color: lightcoral;
            text-decoration: line-through;
        }

        nav,
        nav ul {
            display: inline-block;
        }

        .tags ul,
        footer ul {
            padding: 0;
            display: inline;
        }

        header h1 {
            display: inline-block;
            min-width: 320px;
            max-width: 50%;
            width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: auto;
        }

        @media screen and (max-width: 1200px) {
            body {
                width: 90%;
                max-width: 720px;
                padding: 0;
                margin: 1em auto;
            }

            header h1 {
                max-width: 90%;
                width: 90%;
            }
        }

        nav li,
        .tags li,
        footer li {
            display: inline;
            border-right: 1px solid darkgray;
            padding: 0 1em;
        }

        nav li:last-child,
        .tags li:last-child,
        footer li:last-child {
            border: none;
        }

        .post-list h3 {
            margin: 0.3em 0;
        }

        blockquote {
            margin: 0.5em;
            border: 1px dotted darkgrey;
            border-radius: 0.5em;
            padding: 0 1em;
        }

        div.image-description {
            text-align: center;
            color: gray;
            font-size: smaller;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #090810;
                color: floralwhite;
                opacity: 0.83;
            }

            pre {
                background-color: #282a36;
            }
        }
    </style>
</head>

<body>

    <header>
        
        <h1 title="Java 中的不可变性问题">Java 中的不可变性问题</h1>
        
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/articles">Articles</a></li>
                <li><a href="/about">About</a></li>
            </ul>
        </nav>
        <hr>
        <span class="field">Author: <a href="/about">KimmyLeo</a></span>
        
    </header>
    <article>
        <h1 id="the-problem-of-immutability-in-java">The Problem of Immutability in Java</h1>
<h1 id=""></h1>
<blockquote>
<p>原文作者 Bartłomiej Mazur，Allegro Tech 后端工程师</p>
</blockquote>
<p>As a developer interested in both web technologies and game development I always found myself disagreeing with a large part of articles about using a particular technology to solve some problems. While such articles are often true, they often skip some important details that make given solution unacceptable in some other cases. And in this article I will try to look at immutability in a negative way from game development perspective and how it can affect web services too. It is always more fun to look in a negative way at something everyone loves ;)</p>
<p>作为一个同时对Web技术和游戏开发都深有兴趣的开发者，我发现自己总是不赞同一大部分的使用特定技术解决某些问题的文章。尽管这些文章大部分时候是正确的，他们通常会略过很多细节，而这些细节在某些场景下会让文章中给出的方案无效。这篇文章我尝试从一个消极的方式从游戏开发和Web服务开发的角度来探讨一下“不可变性”。以消极的方式去解读大家都喜欢的东西，总是能带来更多乐趣。</p>
<p>So what are these problems:</p>
<ul>
<li>how hard it is to use immutable pattern correctly in Java compared to other languages</li>
<li>impact on the performance in Java, and how other languages deal with it</li>
</ul>
<p>这是我准备在本文探讨的问题：</p>
<ul>
<li>与其他编程语言相比，在Java中正确地使用不可变模式有多困难</li>
<li>不可变性对Java性能造成的影响，以及其他编程语言是怎么解决它的</li>
</ul>
<p>While I can’t really propose any good solution for these problems I hope I will be able to show you that while immutability is a great tool, not all languages are fully ready to utilize all benefits, and in some cases immutability might even cause some issues. My motivation for this article is the huge amount of articles recommending immutability for every problem without analysing how it can actually affect your application in some cases.</p>
<p>其实我并不能针对上面的问题给出什么好的解决方案，我仍希望这篇文章能够告诉你，尽管“不可变”这点非常好用，然而并非所有编程语言都能够驾驭它，充分获取不可变性带来的所有好处，甚至在某些场景下，不可变性还会带来一些问题。这篇文章的动机源自于一大堆推荐不可变性的文章，这些文章建议使用不可变性解决所有问题，却没有分析这到底对你的应用有什么其他不好的影响。</p>
<h2 id="immutability-across-languages">Immutability across languages</h2>
<h2 id="不同编程语言中的不可变性">不同编程语言中的不可变性</h2>
<p>In most cases immutability is a powerful tool that allows us to keep our code clean and simple even in a multithreaded environment. Each language allow us to write such code in a different way, and the majority of popular languages just allow us to define all fields of such object as final/readonly/notmutable. For example, in Java our immutable type definition would look like this:</p>
<p>大部分情况下，不可变性是一个非常强大的工具，可以允许我们在多线程的环境下保持代码的简单整洁。每种语言都允许我们以不同的方式写出这样的代码，绝大部分编程语言仅仅允许我们声明一些对象的某字段是 final/readonly/notmutable。比如，在Java中一个不可变类型的定义如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EnemyType type;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
    <span class="hljs-comment">// +constructor</span>
}</code></pre>
<p>We need to keep in mind and remember that every referenced object must be immutable too. If we added a field with a list in it, we would either need to use some <code>ImmutableList</code> as field type or ensure in constructor that provided list is copied to some immutable collection. A common mistake here is using and trusting <a href="https://projectlombok.org/features/Value" title="null">lombok</a>. Adding <code>@Value</code> to our class does not magically handle immutability of collections and other references for us. This is similar to using Kotlin, but mostly when using Kotlin code from Java. Because even if Kotlin list appears immutable it is just compiler syntax sugar, and your List will get compiled to normal mutable Java list type, and depending on how the list was created it might be mutable too.</p>
<p>需要牢记的一点是，要保证一个对象整体不可变，所有引用的对象也都必须是不可变的。如果我们添加了一个List字段，那么就需要使用一些比如<code>ImmutableList</code>的构造或者保证构造函数中提供的列表是来自于一些不可变集合。这里常见的错误是过度相信<a href="https://projectlombok.org/features/Value" title="null">lombok</a>。添加一个<code>@Value</code>注解到我们的类上，并不会发生什么魔幻操作导致我们的集合（或者其他引用对象）不可变。使用Kotlin也有同样的问题，通常见于在Java中引用Kotlin代码。因为即便Kotlin的list是不可变的，那也只是编译器的语法糖，你的List对象依然会被编译成普通的Java list，并且根据这个list创建的场景，它也可能是可变的。</p>
<p>Some languages provide more interesting constructs, for example <a href="https://dlang.org/spec/const3.html" title="null">D language</a>:</p>
<p>一些编程语言提供了更有趣的构造，比如<a href="https://dlang.org/spec/const3.html" title="null">D语言</a>：</p>
<pre><code class="language-d"><span class="hljs-keyword">class</span> C {
<span class="hljs-comment">/* 默认可变 */</span>          C mField;
             <span class="hljs-keyword">const</span>     C cField;
             <span class="hljs-keyword">immutable</span> C iField;
}
<span class="hljs-comment">// 接下来</span>
    C c = <span class="hljs-keyword">new</span> C();
    c.mField = c; <span class="hljs-comment">// 没问题</span>

    <span class="hljs-comment">// 编译期错误，因为我们尝试去改变一个不可变字段`iField` ———— 注意它是间接被改变的，</span>
    <span class="hljs-comment">// 实际上我们要去改变的是它内部的可变字段。</span>
    c.iField.mField.mField = c;

    <span class="hljs-keyword">immutable</span> C c = <span class="hljs-keyword">new</span> C();
    c.mField = c; <span class="hljs-comment">// 错误</span>

<span class="hljs-comment">// 或者直接声明整个类型都是不可变的</span>
<span class="hljs-keyword">immutable</span> <span class="hljs-keyword">class</span> X {
    <span class="hljs-keyword">int</span> a;
}</code></pre>
<p>Here we can define each field/parameter as either normal mutable variable, const/final one — so we can’t change the value of that variable, or to mark a field directly as immutable one. Then no matter what, we don’t need to worry about mutating anything in that variable, even if it is a reference that contains mutable fields inside them — we will not be able to mutate them using our immutable reference.</p>
<p>这里我们可以定义每一个字段/参数作为常规的可变对象，或者是不可变对象————这样我们就无法改变这个对象的值了，或者直接标记整个类型都是不可变的。无论怎么标记，我们都不用担心会修改到这个对象的任何一个部分；甚至在这个对象内部包含可变字段的时候，我们也没办法通过一个不可变引用去修改到他们。</p>
<p><a href="https://doc.rust-lang.org/1.29.0/book/first-edition/mutability.html" title="null">Rust</a> is another interesting example. Here by default everything is immutable but at the same time there is the <code>Cell</code> type that can be used to skip immutability, so</p>
<p>另一个有趣的例子是<a href="https://doc.rust-lang.org/1.29.0/book/first-edition/mutability.html" title="null">Rust</a>。Rust中默认所有对象都是不可变的，但与此同时<code>Cell</code>类型可以用来跳过不可变性验证，所以：</p>
<pre><code class="language-rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> {
    x: <span class="hljs-built_in">i32</span>,
    y: <span class="hljs-built_in">i32</span>,
}
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = Point { x: <span class="hljs-number">5</span>, y: <span class="hljs-number">6</span> };
a.x = <span class="hljs-number">10</span>;

<span class="hljs-keyword">let</span> b = Point { x: <span class="hljs-number">5</span>, y: <span class="hljs-number">6</span> };
b.x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误：不能给不可变字段 `b.x` 赋值。 </span>

<span class="hljs-comment">// 但是</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> {
    x: <span class="hljs-built_in">i32</span>,
    y: Cell&lt;<span class="hljs-built_in">i32</span>&gt;,
}
<span class="hljs-keyword">let</span> point = Point { x: <span class="hljs-number">5</span>, y: Cell::new(<span class="hljs-number">6</span>) };

point.y.set(<span class="hljs-number">7</span>); <span class="hljs-comment">// 这样就可以了～</span></code></pre>
<p>So we can’t be sure that our reference is fully immutable either, but if it is, it was a fully conscious choice of the code’s author, so we probably don’t need to worry about it.</p>
<p>因此这样我们也没法确定我们的对象是否完全不可变，但如果是可变的，那也完全是代码作者有意为之，我们就没必要担心了。</p>
<p>My point is: Java has one of the worst ways of defining immutability and tools like Lombok and Kotlin often only hide this instead of helping. While immutability is promising to keep developers safe from many issues, it’s not that easy to keep immutable values safe from developers without better support from the language itself. But why is that? Was Java never designed to be used with immutable values?</p>
<p>我的点在于：Java使用了最糟糕的定义不可变性的方式，并且像Lombok和Kotlin这些通常会更多地隐藏问题。不可变性据说是可以解决开发者面临的绝大多数问题的，但在语言层面没有保障的时候让开发者来保证对象的不可变性并不是件容易的事情。为什么会出现这种情况呢？Java从来没有考虑过不可变对象的问题？</p>
<h2 id="performance-cost-of-immutability-in-java">Performance cost of immutability in Java</h2>
<h2 id="java-不可变性带来的性能消耗">Java 不可变性带来的性能消耗</h2>
<p>We all know (I hope so) about the good sides of using immutable values, mostly related to multi-threaded code, but did you ever wonder what the trade-off is? In many native languages such immutable objects usage can often be heavily optimized and a lot of allocations are just skipped, but that’s not the case with Java — it can still reduce the number of allocations but in a much more limited way. Many people don’t think about it, but you can allocate objects/memory fast enough to slow down your application to noticeable degree. Application then will both spend more time allocation objects and then on cleaning them up duringing GC. To cause such issues you need to constantly allocate a lot of objects in very short time, so in a typical web application it’s not that easy to encounter issues with allocation rates. And when it happens you can tweak a few GC settings and scale your application.</p>
<p>（至少我希望）大家都知道使用不可变对象的好处————大部分都是在多线程场景下，但你有想过这样做的代价是什么吗？大部分native编程语言，这样的不可变对象通常被高效地优化，省去了非常多的空间分配（allocation）过程，Java的情况却并非如此————确实能够省掉一些空间分配，但是情况十分有限。很多人从来没考虑过这个问题，你可以尝试分配大量对象/内存导致可感知地拖慢你应用的情况看一下。这个时候应用会在分配对象和GC（Garbage Collection，垃圾回收）的过程中清理这些对象上花费大量时间。要验证这个场景你需要在短时间内不断分配大量的对象，在一个常规的Web应用中并不太容易遇到这种情况。当真的出现的时候，你可以调整GC的设置或者扩展你的应用。</p>
<p>Imagine a piece of game code where we want to invoke a function for generated positions in world:</p>
<p>考虑下面这段游戏代码， 我们想要调用函数处理游戏世界中生成的位置信息：</p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example</span><span class="hljs-params">(Supplier&lt;Position&gt; positionGenerator, World world)</span> </span>{
        Stream.generate(positionGenerator)
            .limit(<span class="hljs-number">1000000</span>)
            .forEach(pos -&gt; world.updateAt(pos));
    }
}</code></pre>
<p>This is what the update itself looks like:</p>
<p>这是<code>updateAt</code>函数的结构：</p>
<pre><code class="language-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">World</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateAt</span><span class="hljs-params">(Position position)</span> </span>{
        position.forAllNeighborsInRange(<span class="hljs-number">3</span>, newPosition -&gt; spawnMonsterIfNotPresent(newPosition)); <span class="hljs-comment">// cube 7x7x7</span>
        spawnChestIfNotPresent(position);
    }
}</code></pre>
<p>In games such a thing would probably be part of game loop, running dozens of times per second. Maybe not necessarily spawning new monsters, but definitely there is always a lot to do.</p>
<p>这段代码可能是游戏循环的一部分，每秒运行数十次。可能并不一定是生成新的怪物等，但总有很多事情需要这样处理。</p>
<p>We will use <a href="https://openjdk.java.net/projects/code-tools/jmh/" title="null">JMH</a> for benchmarking. Full benchmark code will be linked at the end of article.</p>
<p>我们使用<a href="https://openjdk.java.net/projects/code-tools/jmh/" title="null">JMH</a>来做benchmark。文章后面会给出完整的benchmark代码。</p>
<pre><code class="language-java"><span class="hljs-meta">@Benchmark</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    Stream.generate(positionGenerator)
            .limit(ITERATIONS)
            .forEach(pos -&gt; world.updateAt(pos));
}</code></pre>
<p>Let’s just benchmark such code and see the results</p>
<p>我们看一下benchmark的结果：</p>
<pre><code><span class="hljs-attribute">Benchmark</span>       Score   Error  Units
<span class="hljs-attribute">tick</span>            <span class="hljs-number">68</span>.<span class="hljs-number">875</span>  <span class="hljs-number">0</span>.<span class="hljs-number">088</span>  ms/op
<span class="hljs-attribute">tick</span>:tick p<span class="hljs-number">0</span>.<span class="hljs-number">99</span> <span class="hljs-number">71</span>.<span class="hljs-number">620</span>         ms/op</code></pre>
<p>This already limits us to 14 (1000 ms / 71 ms ≈ 14) updates per second, but we probably want to do more than this. What if we removed all allocations here? Let’s make our Position mutable and just pass the same instance. We only use 1 thread here so we don’t need to worry about concurrency or other possible issues as long as position is not stored anywhere:</p>
<pre><code><span class="hljs-attribute">Benchmark</span>                     Score   Error  Units
<span class="hljs-attribute">tickNoAlloc</span>                   <span class="hljs-number">30</span>.<span class="hljs-number">817</span>  <span class="hljs-number">0</span>.<span class="hljs-number">019</span>  ms/op
<span class="hljs-attribute">tickNoAlloc</span>:tickNoAlloc p<span class="hljs-number">0</span>.<span class="hljs-number">99</span> <span class="hljs-number">31</span>.<span class="hljs-number">130</span>         ms/op</code></pre>
<p>It’s twice as fast! We don’t do much in that code, so you might think that in general such optimization would not matter, but remember that we are talking about something running in a game loop, 35ms less means we can spin our game loop faster or add more features before our game will run too slow, and that’s a lot of time!</p>
<p>In other languages people often try to connect benefits of immutable code and less allocation by allocating such values on the stack. Sadly Java once again does not have any tool for that (Java can get rid of allocations in some cases, but these are internal JIT optimizations that we can’t control or assume if/when they are used). The only alternative would be to use raw values directly, so instead of passing a Position object we can just pass 3 double values. In java we have no way to return 3 values at once (structures would solve this too), so our generator of positions must support generation of each value (x/y/z) separately.</p>
<pre><code><span class="hljs-attribute">Benchmark</span>                   Score   Error  Units
<span class="hljs-attribute">tickNoHeap</span>                  <span class="hljs-number">23</span>.<span class="hljs-number">562</span>  <span class="hljs-number">0</span>.<span class="hljs-number">012</span>  ms/op
<span class="hljs-attribute">tickNoHeap</span>:tickNoHeap p<span class="hljs-number">0</span>.<span class="hljs-number">99</span> <span class="hljs-number">23</span>.<span class="hljs-number">839</span>         ms/op</code></pre>
<p>And not only it does run faster now, but can also be used again in multithreaded way without any issues. The only issue is that we would not be able to do this with larger objects, and it already looks much more complicated and less readable, and all of this because Java lacks simple structures that can be allocated on stack (but maybe someday we will see some form of structures thanks to <a href="https://openjdk.java.net/projects/valhalla/" title="null">Valhalla</a> project). Note that using a struct would not always be better, it depends on size of our data. If we use large object then it would be better to use normal object/reference as copying it would cost more than cost of dereferencing it later.</p>
<h2 id="stressing-gc">Stressing GC</h2>
<p>Now let’s run this code using more threads and see what happens:</p>
<pre><code class="language-java"><span class="hljs-meta">@Benchmark</span>
<span class="hljs-meta">@Threads(-1)</span> <span class="hljs-comment">// use all cores</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tick_threaded</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    Stream.generate(positionGenerator)
            .limit(ITERATIONS)
            .forEach(pos -&gt; world.updateAt(pos));
}
<span class="hljs-meta">@Benchmark</span>
<span class="hljs-meta">@Threads(-1)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tickNoHeap_threaded</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    IntStream.rangeClosed(<span class="hljs-number">0</span>, ITERATIONS)
            .forEach(pos -&gt; world.updateAt_NoHeap(noHeapPositionGenerator.nextX(), noHeapPositionGenerator.nextY(), noHeapPositionGenerator.nextZ()));
}</code></pre>
<p>And results:</p>
<pre><code><span class="hljs-attribute">Benchmark</span>                                     Score   Error  Units
<span class="hljs-attribute">tickNoHeap_threaded</span>                            <span class="hljs-number">29</span>.<span class="hljs-number">051</span> <span class="hljs-number">0</span>.<span class="hljs-number">076</span>  ms/op
<span class="hljs-attribute">tickNoHeap_threaded</span>:tickNoHeap_threaded p<span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">25</span>.<span class="hljs-number">330</span>        ms/op
<span class="hljs-attribute">tickNoHeap_threaded</span>:tickNoHeap_threaded p<span class="hljs-number">0</span>.<span class="hljs-number">95</span>  <span class="hljs-number">40</span>.<span class="hljs-number">567</span>        ms/op
<span class="hljs-attribute">tickNoHeap_threaded</span>:tickNoHeap_threaded p<span class="hljs-number">0</span>.<span class="hljs-number">99</span>  <span class="hljs-number">51</span>.<span class="hljs-number">773</span>        ms/op
<span class="hljs-attribute">tick_threaded</span>                                 <span class="hljs-number">189</span>.<span class="hljs-number">682</span> <span class="hljs-number">0</span>.<span class="hljs-number">849</span>  ms/op
<span class="hljs-attribute">tick_threaded</span>:tick_threaded p<span class="hljs-number">0</span>.<span class="hljs-number">00</span>             <span class="hljs-number">101</span>.<span class="hljs-number">712</span>        ms/op
<span class="hljs-attribute">tick_threaded</span>:tick_threaded p<span class="hljs-number">0</span>.<span class="hljs-number">95</span>             <span class="hljs-number">231</span>.<span class="hljs-number">224</span>        ms/op
<span class="hljs-attribute">tick_threaded</span>:tick_threaded p<span class="hljs-number">0</span>.<span class="hljs-number">99</span>             <span class="hljs-number">256</span>.<span class="hljs-number">379</span>        ms/op</code></pre>
<p>Now we can see this issue even more, as we are allocating a lot of objects that later need to be cleaned up.</p>
<p>Another thing we can check is what will happen if we want to limit available memory. Currently all the code was running on 2GB of memory, that is quite a lot for code which does nothing. Let’s limit memory to 128MB and 20MB:</p>
<pre><code><span class="hljs-attribute">Benchmark</span>                                             Score     Error  Units
<span class="hljs-attribute">tickNoHeap_threaded128M</span>                                <span class="hljs-number">26</span>.<span class="hljs-number">313</span>   <span class="hljs-number">0</span>.<span class="hljs-number">104</span>  ms/op
<span class="hljs-attribute">tickNoHeap_threaded128M</span>:tickNoHeap_threaded<span class="hljs-number">128</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">00</span>  <span class="hljs-number">24</span>.<span class="hljs-number">674</span>          ms/op
<span class="hljs-attribute">tickNoHeap_threaded128M</span>:tickNoHeap_threaded<span class="hljs-number">128</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">99</span>  <span class="hljs-number">45</span>.<span class="hljs-number">200</span>          ms/op
<span class="hljs-attribute">tickNoHeap_threaded20M</span>                                 <span class="hljs-number">26</span>.<span class="hljs-number">292</span>   <span class="hljs-number">0</span>.<span class="hljs-number">093</span>  ms/op
<span class="hljs-attribute">tickNoHeap_threaded20M</span>:tickNoHeap_threaded<span class="hljs-number">20</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">00</span>    <span class="hljs-number">24</span>.<span class="hljs-number">707</span>          ms/op
<span class="hljs-attribute">tickNoHeap_threaded20M</span>:tickNoHeap_threaded<span class="hljs-number">20</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">99</span>    <span class="hljs-number">41</span>.<span class="hljs-number">484</span>          ms/op
<span class="hljs-attribute">tick_threaded128M</span>                                     <span class="hljs-number">211</span>.<span class="hljs-number">826</span>   <span class="hljs-number">0</span>.<span class="hljs-number">726</span>  ms/op
<span class="hljs-attribute">tick_threaded128M</span>:tick_threaded<span class="hljs-number">128</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">00</span>             <span class="hljs-number">184</span>.<span class="hljs-number">812</span>          ms/op
<span class="hljs-attribute">tick_threaded128M</span>:tick_threaded<span class="hljs-number">128</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">99</span>             <span class="hljs-number">240</span>.<span class="hljs-number">910</span>          ms/op
<span class="hljs-attribute">tick_threaded20M</span>                                      <span class="hljs-number">427</span>.<span class="hljs-number">533</span>   <span class="hljs-number">1</span>.<span class="hljs-number">430</span>  ms/op
<span class="hljs-attribute">tick_threaded20M</span>:tick_threaded<span class="hljs-number">20</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">00</span>               <span class="hljs-number">411</span>.<span class="hljs-number">042</span>          ms/op
<span class="hljs-attribute">tick_threaded20M</span>:tick_threaded<span class="hljs-number">20</span>M p<span class="hljs-number">0</span>.<span class="hljs-number">99</span>               <span class="hljs-number">478</span>.<span class="hljs-number">224</span>          ms/op</code></pre>
<p>New version with objects is struggling even more to maintain good performance, and this is actually something you might observe in your web application too, when more and more time goes for GC and allocation. Some of these issues can be sometimes solved (or make them less visible) by adjusting young gen size. Issue will still be there, but now it will occur at another point, and at the end you will finally hit a limit of how much you can scale your application vertically.</p>
<h2 id="conclusion">Conclusion?</h2>
<p>The point of this article was to show that while immutability gives us a lot of safety, Java does not give us enough tools to use immutable data in a performant way. While it’s still a good idea to write code using immutable values, we should sometimes also consider using other methods if we need much higher throughput and scaling horizontally is either impossible or just starting to get too expensive (with games you are often limited by performance of a single PC). As a wannabe game developer myself — I’m especially looking at other web developers interested in game development, as reading web influenced game code often hurts, not only the performance of the game, but also the people who will read that code later ;)</p>
<p>Immutability is just a tool in a software engineer’s hand, and every tool has its own good uses, but there is no universal tool and the job of a software engineer is to choose the right tools for given job.</p>
<p><a href="https://gist.github.com/GotoFinal/2f057616f300045c7638bd11b250c20a" title="null">Full source code for benchmark can be read on gist</a></p>

        

    </article>
    <!-- <div>
        <h5>See Also</h5>
        <ul>
            <li><a href="/about">About Me</a></li>
        </ul>
    </div> -->
    <span class="field">创建时间：#N/A</span>
    <span class="field">最近更新时间：2020-12-30</span>
    <hr>
    <footer>
        <ul>
            <li><a href="/about">关于我</a></li>
            <li><a href="/sitemap.xml">站点地图</a></li>
            <li><a href="/rss.xml">RSS</a></li>
            <li>Copyright &copy; KimmyLeo</li>
        </ul>
    </footer>
    <script type="text/javascript">
        document.querySelectorAll(".disabled-link").forEach(el => el.addEventListener("click", (e) => {
            alert("链接页面不存在！");
            e.preventDefault();
        }));
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script
</body>

</html>