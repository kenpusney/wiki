<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript">
        if (location.href.endsWith("index.html")) {
            location.href = location.href.substring(0, location.href.length - "index.html".length);
        }
    </script>
    
    <title>说说 Typescript</title>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
        media="(prefers-color-scheme: light)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/dracula.min.css"
        media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
        media="(prefers-color-scheme: no-preference)">
    <style type="text/css">
        body {
            width: 60%;
            margin: 0 auto;
            padding: 2em;
            font-family: 'Segoe UI',
                "Microsoft Yahei Light",
                "San Francisco",
                "Ping Fang SC",
                "Roboto",
                "Noto Sans CJK",
                Tahoma, Geneva, Verdana, sans-serif;
        }

        p > img {
            margin: 0 auto;
            display: block;
            max-width: 80%;
        }

        span.field {
            display: inline-block;
            font-weight: bolder;
            font-size: smaller;
        }

        pre {
            max-width: 90%;
            overflow-x: scroll;
            padding: 1em;
            border-radius: 5px;
        }

        a {
            text-decoration: none;
            color: cornflowerblue;
        }

        a:visited {
            color: cornflowerblue;
        }

        a:hover {
            color: darkgray;
        }

        a.disabled-link {
            color: lightcoral;
            text-decoration: line-through;
        }

        nav,
        nav ul {
            display: inline-block;
        }

        .tags ul,
        footer ul {
            padding: 0;
            display: inline;
        }

        header h1 {
            display: inline-block;
            min-width: 320px;
            max-width: 50%;
            width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: auto;
        }

        @media screen and (max-width: 1200px) {
            body {
                width: 90%;
                max-width: 720px;
                padding: 0;
                margin: 1em auto;
            }

            header h1 {
                max-width: 90%;
                width: 90%;
            }
        }

        nav li,
        .tags li,
        footer li {
            display: inline;
            border-right: 1px solid darkgray;
            padding: 0 1em;
        }

        nav li:last-child,
        .tags li:last-child,
        footer li:last-child {
            border: none;
        }

        .post-list h3 {
            margin: 0.3em 0;
        }

        blockquote {
            margin: 0.5em;
            border: 1px dotted darkgrey;
            border-radius: 0.5em;
            padding: 0 1em;
        }

        div.image-description {
            text-align: center;
            color: gray;
            font-size: smaller;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #090810;
                color: floralwhite;
                opacity: 0.83;
            }

            pre {
                background-color: #282a36;
            }
        }
    </style>
</head>

<body>

    <header>
        
        <h1 title="说说 Typescript">说说 Typescript</h1>
        
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/articles">Articles</a></li>
                <li><a href="/about">About</a></li>
            </ul>
        </nav>
        <hr>
        <span class="field">Author: <a href="/about">KimmyLeo</a></span>
        
    </header>
    <article>
        <p>今天一早就看到 GitHub 收购 NPM 的新闻，也恭喜微软把前端的一大主要的工具链成功地集成到了自己的麾下。现在微软的前端生态上，<strong>编辑器</strong>有 VSCode，<strong>代码托管</strong>有 GitHub，<strong>包管理</strong>有 NPM，<strong>编译工具链</strong>有 TypeScript。当然还有本身来自微软自己的一些东西，像 Node-ChakraCore 和 FarbricUI 等，终于成了前端大厂。</p>
<p>然后群里就聊起来说，TypeScript 到底有什么用？很多时候框架层的类型标注非常复杂，会给开发者带来一些不必要的负担，并且因为 TS 只是进行编译过程，很难解决前后端通信的时候进行的 contract validation。那这个时候，作为研发团队为什么要引入 TypeScript 呢？</p>
<h2 id="typescript-能干什么">TypeScript 能干什么</h2>
<p>在这之前我们先看一下 TypeScript 能干什么。</p>
<p>以下面这段代码为基础，我们定义了 4 个函数。除了仅有的两个参数标记了类型之外，其他跟 JavaScript 的函数定义完全一致。</p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnRetrunsString</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnDoesNothing</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnAcceptsNumberReturnsEitherNumberOrString</span>(<span class="hljs-params">s: <span class="hljs-built_in">number</span></span>) </span>{
    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> s;
    }
    <span class="hljs-keyword">return</span> fnRetrunsString();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnTakesString</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) </span>{
    <span class="hljs-keyword">return</span> s;
}</code></pre>
<p>然后我们尝试用 TypeScript 编译器（<code>tsc</code>）编译下面这段代码：</p>
<pre><code class="language-typescript">fnTakesString(fnRetrunsString());
fnTakesString(fnDoesNothing());
fnTakesString(fnAcceptsNumberReturnsEitherNumberOrString(-<span class="hljs-number">1</span>));</code></pre>
<p>各位可以简单动手试一下，或者细想一下会发生的事情再继续阅读。这里到底 TypeScript 到底会对这段代码怎么处理，又回报什么错误。</p>
<p>我们插个话题，渐进式类型（Gradual Typing）。</p>
<h3 id="渐进式类型-gradual-typing">渐进式类型 Gradual Typing</h3>
<p>熟悉 JavaScript 的朋友肯定知道动态类型这个概念。<strong>类型就是解析对象方式的标签</strong>，比如 number 类型，则说明这个对象是一个数字，string 类型，则说明这个对象是一个字符串。在 JavaScript 等之类的语言中，变量的类型是可变的，这一特性可以使得 JavaScript 在作为一种脚本语言的情况下更灵活的适用各种场景。比如我有一个数组，那这个数组里可以随意地塞数字（number）或者字符串（string）或者甚至是嵌套无限层的数组和对象。</p>
<p>但这样通常会出现一些问题，比如当我们明确想要知道某些数据的类型的时候，就必须进行运行时的判断，于是 JavaScript 就提供了<code>typeof</code>和<code>instanceof</code>两个运算符，来帮我们做这些事情。</p>
<p>然后问题就来了，你可能经常会看到代码里出现这些神奇的操作：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingBasedOnTypeOfParam</span>(<span class="hljs-params">param</span>) </span>{
    <span class="hljs-keyword">if</span> (param === <span class="hljs-literal">null</span> || param === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;number&quot;</span>) {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;string&quot;</span>) {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">if</span> (param.hasOwnProperty(<span class="hljs-string">&quot;foo&quot;</span>)) {
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// more IFs ...</span>
}</code></pre>
<p>因为 JavaScript 是动态类型语言，我们没办法在写代码的时候就知道参数<code>param</code>的值，于是只好写大量的<strong>守卫（guard）代码</strong>来对类型进行判断和检查。而往往这个时候就非常需要一个特性，让这个编程语言能够给你在这一部分做个限制。</p>
<p>比如同样的场景放在 Java 里面，就会是这样子的：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomethingBasedOnTypeOfParam</span><span class="hljs-params">(String param)</span> </span>{
    <span class="hljs-comment">// do with string</span>
}</code></pre>
<p>同样的调用代码<code>doSomethingBasedOnTypeOfParam(0)</code>，在 Java 里面就会造成<strong>编译错误</strong>。</p>
<p>这就是静态类型存在的场景。这样做的好处是提前暴露调用方的错误操作，并且减轻接口提供方的负担。在这种情况下约定的接口保持一致，就不会破坏整个前后协作上的一致性。做到了这种程度，我们就可以说这样的程序是<strong>类型安全</strong>的（type safe）。</p>
<p>静态类型语言就会有一个这种<strong>类型安全检查</strong>（type checking）的过程，确保程序中所有的代码复合类型安全性要求。但是这个过程都是在编译时完成的，没办法做到运行时的保障。换句话说当你尝试绕过静态类型检查，在运行时取到函数入口，随便塞些什么作为参数调用的时候，该出错的还是会出错；或者适用类型降级的方式，比如参数入口用<code>Map&lt;String, Object&gt;</code>，给自己制造麻烦。</p>
<p>什么是渐进式类型呢，通常是这两种原因产生的：1. 动态类型语言，希望加入前面的静态类型检查机制，来提升类型安全性，比如 TypeScript；2. 静态类型语言，希望加入动态类型来提升代码的表达力和灵活性，比如 C#。（<em>咋都跟 Anders Hejlsberg 有关系</em>）</p>
<p>先说后者，其实问题还没那么严重，因为通常的实现都是在原本运行时之上再加一个动态运行时（比如 DLR），而本身的静态类型部分的安全性，还是有强保障。但对于动态类型语言加上静态类型检查的做法，这一点就很难处理了。原因很简单，这种安全检查只能加在编译期，运行时还依然是原本裸奔的状态。</p>
<h3 id="typescript-的尴尬">TypeScript 的尴尬</h3>
<p>TypeScript 就处在这么一个尴尬的位置上。</p>
<p>JavaScript 语言的动态性不只是类型可以随时变。对象模型也是在运行期可以进行各种操作的，反正拿到构造器的 <code>prototype</code> 往上面加方法就好了。这个时候 TypeScript 完全就成了鸡肋一样的存在。举个例子：</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BaseObject</span>(<span class="hljs-params"></span>) </span>{
}

BaseObject.prototype.defineMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, fn</span>) </span>{
    BaseObject.prototype[name] = fn;
};</code></pre>
<p>你永远都不知道 <code>BaseObject</code> 的对象会在运行时多出什么诡异的方法来，而这也正是很多基础框架会做的事情：读到一些模版或者配置，编译处理之后在 JavaScript 运行时生成一些对象。这个时候只能靠框架设计者自觉地提供合理靠谱的<code>.d.ts</code>来确保类型检查了。</p>
<p>但撇开这些坑人的框架，剩下的部分 TypeScript 可以充分胜任。</p>
<h3 id="类型检查和推导">类型检查和推导</h3>
<p>我们回到前面提到的三行代码：</p>
<pre><code class="language-typescript">fnTakesString(fnRetrunsString());
fnTakesString(fnDoesNothing());
fnTakesString(fnAcceptsNumberReturnsEitherNumberOrString(-<span class="hljs-number">1</span>));</code></pre>
<ul>
<li>第一行是类型安全的，TypeScript 也不会向你抱怨什么。</li>
<li>第二行就开始出问题了：<code>void</code>不是<code>string</code>。</li>
<li>第三行也是有问题的：<code>string | number</code>不是<code>string</code>。</li>
</ul>
<p>这里除了 fnTakesString 中参数类型之外，我们是没有额外标注诸如<code>void</code>或者<code>string | number</code>这样的信息的。能够正确得出这样的信息，就是因为 TypeScript 对整个代码进行类型检查的过程中，还对未知类型的部分做了推导。</p>
<p>最开始的这四个函数定义中，TypeScript 分别能推导出来的类型是：</p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnRetrunsString</span>(<span class="hljs-params"></span>): <span class="hljs-title">string</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnDoesNothing</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnAcceptsNumberReturnsEitherNumberOrString</span>(<span class="hljs-params">s: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnTakesString</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span></span></span></span></code></pre>
<p>这四个类型签名基本上跟代码和我们希望表达的逻辑是一致的。</p>
<p>而如果你尝试把 <code>fnDoesNothing</code> 的定义修改成：</p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnDoesNothing</span>(<span class="hljs-params"></span>): <span class="hljs-title">any</span> </span>{}</code></pre>
<p>会发现<code>fnTakesString(fnDoesNothing())</code>的错误提示不存在了。这个操作就是在错误的引导 TypeScript 的类型检查，因为 any 就是来摆脱强制类型检查用的，加上了 any 反倒是回产生错误的结果。</p>
<p>那假设你真的需要一个通用类型，又不想破坏调用方的类型契约。使用并类型（即前面出现的<code>string | number</code>或者会参与强制检查的<code>Object</code>类型会更好。</p>
<p>这个例子中，对于 <code>fnDoesNothing</code>，就可以变为：</p>
<pre><code class="language-typescript"><span class="hljs-comment">// void 表示函数没有返回值</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnDoesNothing</span>(<span class="hljs-params"></span>): <span class="hljs-title">Object</span> | <span class="hljs-title">void</span> </span>{}

<span class="hljs-comment">// 也可以选择对这个类型做一个alias</span>
<span class="hljs-keyword">type</span> SafeAny = <span class="hljs-built_in">Object</span> | <span class="hljs-built_in">void</span>;</code></pre>
<p>于是<code>fnTakesString(fnDoesNothing())</code>调用中的错误提示又回来了。</p>
<h3 id="typescript-不能干什么">TypeScript 不能干什么</h3>
<p>前面已经说了，TypeScript 只能用于编译时的类型检查，所有超越了编译时的过程都很难通过 TypeScript 来做限制了。</p>
<p>比如前面说起过的，前后端数据通信的验证。拿到后端的数据肯定都是在运行时了，这个过程早就不再是 TypeScript 参与的阶段，而拿到的数据是 JSON 或者其他的序列化结构，也并非常规的 JavaScript 对象。</p>
<p>这个时候一些做法可能是通过 JavaScript 的<strong>装饰器</strong>（decorator）配合<code>reflect-metadata</code>这样的库生成出来运行时可用的信息作为程序的一部分，然后配合做处理（我参与过的 TypeGraphQL 这个框架就采用了这种方式）。另外的做法是引入一些<strong>运行时的类型检查</strong>库来做验证。</p>
<p>我在去年也专门针对这种类型特点的数据设计过一个非常简单的<strong>类型系统</strong><a href="http://kimleo.net/infer/" title=" infer">infer</a>，同时提供了 Java 和 JavaScript 实现来做对运行时无模式的数据进行检查和验证：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { Schema, Union } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;infer-schema&quot;</span>);

<span class="hljs-comment">// 定义类型模式</span>
<span class="hljs-keyword">const</span> Phone = <span class="hljs-keyword">new</span> Schema({
    <span class="hljs-attr">areaCode</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">number</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">extension</span>: <span class="hljs-built_in">String</span>,
});

<span class="hljs-keyword">const</span> Name  = <span class="hljs-keyword">new</span> Schema({
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">middleName</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">String</span>,
});

<span class="hljs-keyword">const</span> Contact = <span class="hljs-keyword">new</span> Schema({
    <span class="hljs-attr">emails</span>: [ { <span class="hljs-attr">tag</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">email</span>: <span class="hljs-built_in">String</span> } ],
    <span class="hljs-attr">phones</span>: [ { <span class="hljs-attr">tag</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">phone</span>: <span class="hljs-keyword">new</span> Union(<span class="hljs-built_in">String</span>, Phone) } ],
});

<span class="hljs-keyword">const</span> Party = <span class="hljs-keyword">new</span> Schema({
    <span class="hljs-attr">nickname</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">names</span>: {
        <span class="hljs-attr">legal</span>: Name,
        <span class="hljs-attr">prefered</span>: Name,
        <span class="hljs-attr">foreign</span>: [ { <span class="hljs-attr">tag</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">name</span>: Name } ],
    },
    <span class="hljs-attr">contact</span>: Contact,
    <span class="hljs-attr">tags</span>: [<span class="hljs-built_in">String</span>],
    <span class="hljs-attr">extensions</span>: <span class="hljs-built_in">Object</span>,
});

<span class="hljs-comment">// 验证数据对象</span>
Party.validate(party);

<span class="hljs-comment">// 生成示例数据</span>
Party.declval();</code></pre>
<h2 id="typescript-最佳实践">TypeScript 最佳实践</h2>
<p>很明显即便是静态类型检查，TypeScript 也还是能阻止很多愚蠢的错误的。所以如果团队成员能够广泛接受静态类型所带来的思维转变，引入 TypeScript 是一个百利无一害的事情。这里就针对本文讨论的一些话题，聊一聊 TypeScript 的最佳实践。</p>
<h3 id="不要使用-any">不要使用 any</h3>
<p><strong>永远记住这一条</strong>。有太多血淋淋的教训都是因为使用了 any 导致整个 TypeScript 类型检查都没了存在的意义。</p>
<p>这样既破坏了 TypeScript 检查的正确性，延后了问题出现的时机，也降低了整个系统的类型准确度和完整度，破坏性非常强。</p>
<p>在团队整体约定好的情况下，你可以参考前面我给出的<code>SafeAny</code>的方案。</p>
<h3 id="尽可能多利用-typescript-的类型推导">尽可能多利用 TypeScript 的类型推导</h3>
<p>通过工具来给出一个自然的类型结果。这样其实有一个好处是能够引导你写出来更简洁直观逻辑，和相容性比较一致的数据结构：TypeScript 推导出的类型也是要满足 KISS 和单一职责原则的，否则这直接说明你代码本身就过度复杂了。</p>
<h3 id="使用-type-alias-和-interface-定义更表意的领域类型">使用 <code>type alias</code> 和 <code>interface</code> 定义更表意的领域类型</h3>
<p>上面的 SafeAny 就是一个例子。在类型标注需要稍微复杂的情况下，仔细考虑这个对象其具备的价值，给出一个表意性强的类型名，比代码中飘着各种基本类型和复合类型要好得多。</p>
<p>另外 type alias 还有一个好处，就是可以把重复的内容抽取到一起，方便改动或者重构。</p>
<h3 id="避免过度的动态操作">避免过度的动态操作</h3>
<p>TypeScript 提供了对动态语言特性的一些支持，但这仍然不能满足现有 JavaScript 的动态性（前文<code>BaseObject</code>的例子）。所以如果涉及到太多动态的操作和现有 TypeScript 的类型系统难以兼容，尽可能避免出现在业务代码中。</p>
<p>如果真的有这个需要，把他们封装起来作为库来提供，并给出满足类型安全性要求的<code>.d.ts</code>声明文件，比直接暴露在原始代码库牺牲整体的类型安全性，要稳妥一些。</p>
<h2 id="结论">结论</h2>
<p>TypeScript 作为给 JavaScript 引入 Gradual Typing 的一个方案，整体的完备性已经非常好了。在团队能力达标的情况下非常值得引入使用。只是运行时的一些操作仍然需要注意多利用社区的生态来完善。</p>
<p>我个人是强烈支持静态类型的，如果你有看过<a href="https://mp.weixin.qq.com/s/E2rfuPvIpUTP2qOHNS40-w" title="null">之前的文章</a>也知道我的态度。无论什么时候，我们都应当追求增强系统整体的安全性，以及让机器（编译器）来代替人工做事情。静态类型检查恰好能满足这一切，不香吗？</p>

        

    </article>
    <!-- <div>
        <h5>See Also</h5>
        <ul>
            <li><a href="/about">About Me</a></li>
        </ul>
    </div> -->
    <span class="field">创建时间：2020-03-17</span>
    <span class="field">最近更新时间：2021-01-22</span>
    <hr>
    <footer>
        <ul>
            <li><a href="/about">关于我</a></li>
            <li><a href="/sitemap.xml">站点地图</a></li>
            <li><a href="/rss.xml">RSS</a></li>
            <li>Copyright &copy; KimmyLeo</li>
        </ul>
    </footer>
    <script type="text/javascript">
        document.querySelectorAll(".disabled-link").forEach(el => el.addEventListener("click", (e) => {
            alert("链接页面不存在！");
            e.preventDefault();
        }));
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script
</body>

</html>