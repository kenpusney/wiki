<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Kimmy's Wiki"><link rel="shortcut icon" href=http://wiki.kimleo.net/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>论面向组合子程序设计方法 之九 南无阿弥陀佛</title></head><body><header id=banner><h2><a href=http://wiki.kimleo.net>Kimmy's Wiki</a></h2><nav><ul><li><a href=/ title=posts>posts</a></li><li><a href=/about/ title=about>about</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>论面向组合子程序设计方法 之九 南无阿弥陀佛</h1><time>January 13, 2006</time></header><p>其实，前面我还忘了提一个非常重要的基本组合子：singleton。
这里补充提一下：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>SingletonComponent</span> <span class=kd>implements</span> <span class=n>Component</span><span class=o>{</span> 
  <span class=kd>private</span> <span class=kd>final</span> <span class=n>Component</span> <span class=n>c</span><span class=o>;</span> 
  <span class=kd>private</span> <span class=n>Object</span> <span class=n>val</span><span class=o>;</span> 
  <span class=kd>public</span> <span class=n>Class</span> <span class=nf>getType</span><span class=o>(){</span> 
    <span class=k>return</span> <span class=n>c</span><span class=o>.</span><span class=na>getType</span><span class=o>();</span> 
  <span class=o>}</span> 
  <span class=kd>public</span> <span class=kd>synchronized</span> <span class=n>Object</span> <span class=nf>create</span><span class=o>(</span><span class=n>Dependency</span> <span class=n>dep</span><span class=o>){</span> 
    <span class=k>if</span><span class=o>(</span><span class=n>val</span><span class=o>!=</span><span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=n>val</span><span class=o>;</span> 
    <span class=n>val</span> <span class=o>=</span> <span class=n>c</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>dep</span><span class=o>);</span> 
    <span class=k>return</span> <span class=n>val</span><span class=o>;</span> 
  <span class=o>}</span> 
  <span class=kd>public</span> <span class=kd>synchronized</span> <span class=n>Class</span> <span class=nf>verify</span><span class=o>(</span><span class=n>Dependency</span> <span class=n>dep</span><span class=o>){</span> 
    <span class=k>if</span><span class=o>(</span><span class=n>val</span><span class=o>!=</span><span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=n>val</span><span class=o>.</span><span class=na>getClass</span><span class=o>();</span> 
    <span class=k>else</span> <span class=k>return</span> <span class=n>c</span><span class=o>.</span><span class=na>verify</span><span class=o>(</span><span class=n>dep</span><span class=o>);</span> 
  <span class=o>}</span> 
<span class=o>}</span>
</code></pre></div><p>代码没什么可说的，就是最简单的singleton模式。</p><p>用这个组合子，我们可以对任意的Component做singleton。</p><p>下面接着说monad。</p><p>有了bind，很多的功能都可以自然推演出来了。</p><p>比如我们前面用来刁难pico的那个例子，甚至，为了更强调复杂性，我们可以给B和A再另外增加一些参数，这些参数要求从容器解析（毕竟，我们之所以需要容器，就是为了自动解析一些依赖关系，要是全部依赖关系都hard-code，意义就不大了）：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kt>void</span> <span class=n>A</span> <span class=nf>createA</span><span class=o>(){</span> 
  <span class=n>B</span> <span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>B</span><span class=o>(...);</span> 
  <span class=k>return</span> <span class=k>new</span> <span class=n>A</span><span class=o>(</span><span class=n>b</span><span class=o>,</span><span class=n>b</span><span class=o>,</span> <span class=o>...);</span> 
<span class=o>}</span>
</code></pre></div><p>用bind，我们的思路可以是这样：
1。用B的构造函数生成一个Component。
2。这个Component生成一个对象，
3。这个产生的对象被传递给一个对应A的Component当作参数。这一步可以用bind来搞定。</p><p>java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Component</span> <span class=n>b_component</span> <span class=o>=</span> <span class=n>Components</span><span class=o>.</span><span class=na>ctor</span><span class=o>(</span><span class=n>B</span><span class=o>.</span><span class=na>class</span><span class=o>);</span> 
<span class=k>return</span> <span class=k>new</span> <span class=n>BoundComponent</span><span class=o>(</span><span class=n>b_component</span><span class=o>,</span> <span class=k>new</span> <span class=n>Binder</span><span class=o>(){</span> 
  <span class=kd>public</span> <span class=n>Component</span> <span class=nf>bind</span><span class=o>(</span><span class=n>Object</span> <span class=n>b</span><span class=o>){</span> 
    <span class=kd>final</span> <span class=n>Component</span> <span class=n>arg</span> <span class=o>=</span> <span class=n>Components</span><span class=o>.</span><span class=na>value</span><span class=o>(</span><span class=n>b</span><span class=o>);</span> 
    <span class=k>return</span> <span class=k>new</span> <span class=n>WithArgument</span><span class=o>(</span> 
      <span class=k>new</span> <span class=n>WithArgument</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>arg</span><span class=o>),</span> 
    <span class=n>1</span><span class=o>,</span> <span class=n>arg</span><span class=o>);</span> 
  <span class=o>}</span> 
<span class=o>});</span> 
</code></pre></div><p>Components.value(Object)是我们写的一个对ValueComponent的封装静态函数。
为了避免总写冗长的new SomeComponent(&mldr;)，我们把一些常用的基本Component都写成名字较短的静态函数，放在Components类里面。</p><p>这样，我们可以写Components.value(obj)，而不是new ValueComponent(obj)。
要是觉得敲键盘还是麻烦，你甚至可以创建一个Components对象cc。然后到处用这个对象：
cc.value(obj)。舒服些了吧？</p><p>从上面的例子，我们可以看到，那个直接创建对象的createA函数中的两个步骤，在我们高阶的Component中也被分为两部。
而在两个步骤之间的信息传递（那个b变量，从第一个步骤取得，然后在第二个步骤使用），则被用bind操作实现了。</p><p>到这，也许我们该伸伸懒腰了。舒服地往椅子背上一靠，说：“啊。终于干完了！我可以用高阶逻辑来模拟任何直接硬编码创建对象的逻辑了”。</p><p>这话倒也没错，有了bind，我们不再被局限于“构造函数注射”，“setter注射”，“静态工厂注射”等寥寥几个注射方式；我们甚至可以对所谓的ioc type嗤之以鼻：“什么type1, type2？不过是我们可以处理的无数种情况中的几种特例而已！”。
我们可以处理if-else，可以处理循环，递归，任何可以直接用java写出来的对象创建方式，我们都可以在高阶逻辑上得到对应的组合版本，只 要我们有足够的原子组合子。（所谓原字组合子，不过是：FunctionComponent, BeanComponent，ValueComponent几种）</p><p>比如，对应于：</p><p>java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>X</span> <span class=nf>createX</span><span class=o>(){</span> 
  <span class=n>A</span> <span class=n>a</span> <span class=o>=</span> <span class=n>A</span><span class=o>.</span><span class=na>instance</span><span class=o>(...);</span> 
  <span class=k>if</span><span class=o>(</span><span class=n>a</span><span class=o>.</span><span class=na>isX</span><span class=o>(...)){</span> 
    <span class=k>return</span> <span class=k>new</span> <span class=n>X</span><span class=o>(...);</span> 
  <span class=o>}</span> 
  <span class=k>else</span><span class=o>{</span> 
    <span class=k>return</span> <span class=k>new</span> <span class=n>Y</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=o>...).</span><span class=na>getX</span><span class=o>(...);</span> 
  <span class=o>}</span> 
<span class=o>}</span>
</code></pre></div><p>这里，所有的省略号都代表可能需要从容器解析的参数。使用高阶Component对象而不是直接调用createX()函数的一个原因，就是我们想要把依赖解析隐藏起来并且集中灵活地配置和管理。</p><p>对此，我们可以写成：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Component</span> <span class=n>a_component</span> <span class=o>=</span> <span class=n>Components</span><span class=o>.</span><span class=na>static_method</span><span class=o>(</span><span class=n>A</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=s>&#34;instance&#34;</span><span class=o>);</span> 
<span class=k>return</span> <span class=k>new</span> <span class=n>BoundComponent</span><span class=o>(</span><span class=n>a_component</span><span class=o>,</span> <span class=k>new</span> <span class=n>Binder</span><span class=o>(){</span> 
  <span class=kd>public</span> <span class=n>Component</span> <span class=nf>bind</span><span class=o>(</span><span class=kd>final</span> <span class=n>Object</span> <span class=n>a</span><span class=o>){</span> 
    <span class=kd>final</span> <span class=n>Component</span> <span class=n>isx_component</span> <span class=o>=</span> <span class=n>Components</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=s>&#34;isX&#34;</span><span class=o>);</span> 
    <span class=k>return</span> <span class=k>new</span> <span class=n>BoundComponent</span><span class=o>(</span><span class=n>isx_component</span><span class=o>,</span> <span class=k>new</span> <span class=n>Binder</span><span class=o>(){</span> 
      <span class=kd>public</span> <span class=n>Component</span> <span class=nf>bind</span><span class=o>(</span><span class=n>Object</span> <span class=n>isx</span><span class=o>){</span> 
        <span class=kd>final</span> <span class=n>Boolean</span> <span class=n>v</span> <span class=o>=</span> <span class=o>(</span><span class=n>Boolean</span><span class=o>)</span><span class=n>isx</span><span class=o>;</span> 
        <span class=k>if</span><span class=o>(</span><span class=n>v</span><span class=o>.</span><span class=na>booleanValue</span><span class=o>()){</span> 
          <span class=k>return</span> <span class=n>Components</span><span class=o>.</span><span class=na>ctor</span><span class=o>(</span><span class=n>X</span><span class=o>.</span><span class=na>class</span><span class=o>);</span> 
        <span class=o>}</span> 
        <span class=k>else</span><span class=o>{</span> 
          <span class=kd>final</span> <span class=n>Coponent</span> <span class=n>y_component</span> <span class=o>=</span> 
           <span class=k>new</span> <span class=n>WithArgument</span><span class=o>(</span><span class=n>Components</span><span class=o>.</span><span class=na>ctor</span><span class=o>(</span><span class=n>Y</span><span class=o>.</span><span class=na>class</span><span class=o>),</span> <span class=n>0</span><span class=o>,</span> 
              <span class=n>Components</span><span class=o>.</span><span class=na>value</span><span class=o>(</span><span class=n>a</span><span class=o>));</span> 
          <span class=k>return</span> <span class=k>new</span> <span class=n>BoundComponent</span><span class=o>(</span><span class=n>y_component</span><span class=o>,</span> <span class=k>new</span> <span class=n>Binder</span><span class=o>(){</span> 
            <span class=kd>public</span> <span class=n>Component</span> <span class=nf>bind</span><span class=o>(</span><span class=n>Object</span> <span class=n>y</span><span class=o>){</span> 
              <span class=k>return</span> <span class=n>Components</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>y</span><span class=o>,</span> <span class=s>&#34;getX&#34;</span><span class=o>);</span> 
            <span class=o>}</span> 
          <span class=o>});</span> 
          
        <span class=o>}</span> 
      <span class=o>}</span> 
    <span class=o>});</span> 
  <span class=o>}</span> 
<span class=o>});</span>
</code></pre></div><p>稍微有点绕，如果你到此有点糊涂的话，请重温一下前面的简单的bind的例子，只要体会了bind的具体意义，上面的代码不过是几层bind的嵌套。</p><p>好，如果你理解了bind，那么应该能够看懂上面的这段代码了。它其实就是那个createX函数的严格翻译。</p><p>功能确实很强大了，就是这代码写起来这个烦啊！对比一下createX和这个高阶版本吧。我发现如果我多看几眼这个所谓的"co"的代码，我简直都要吐！如果说createX这个函数的代码是正常人说话，那么这个高阶代码就是唐僧念经：“南无阿弥陀佛，南无阿弥陀佛，南无阿弥陀佛&mldr;”，天啊！</p><p>如果我们真要Combinator-oriented起来，难道要整天写这种蹩脚代码？是不是我们吐啊吐的就会习惯了呢？
pico的各个ComponentAdapter其实倒也就是这么写，可是pico没有bind，你很少需要写这么深的嵌套，甚至很少需要写匿名类。
如果我们把我们的组件系统比喻作pascal语言的话，pico的那些decorator充其量不过是一个dos的批处理，不，远不如批处理灵活，应该也就是一个简单的用户界面上的几个按钮。</p><p>那么有没有什么办法来简化语法呢？</p><p>倒是有一个想法：
1。把Component从接口变成一个抽象类。然后把一些常用的二元组合，比如bind，比如withArgument，withProperty，比如method，ifelse，都放在这个抽象类里面。这样，</p><p>我们就可以避免写：
new SingletonComponent(c)，而写c.singleton()。
我们就可以避免写：
new BoundComponent(c1, &mldr;)，而写：c1.bind(&mldr;)。
可以避免写：
new WithArgument(c, 0, arg)，而写：c.withArgument(0, arg)。
可以避免写：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=k>new</span> <span class=n>BoundComponent</span><span class=o>(</span><span class=n>c1</span><span class=o>,</span> <span class=k>new</span> <span class=n>Binder</span><span class=o>(){</span> 
  <span class=kd>public</span> <span class=n>Component</span> <span class=nf>bind</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>){</span> 
    <span class=k>return</span> <span class=n>Components</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>obj</span><span class=o>,</span> <span class=s>&#34;method&#34;</span><span class=o>);</span> 
  <span class=o>}</span> 
<span class=o>});</span>
</code></pre></div><p>而写成：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>c1</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=s>&#34;method&#34;</span><span class=o>);</span>
</code></pre></div><p>可以避免写：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=k>new</span> <span class=n>BoundComponent</span><span class=o>(</span><span class=n>c1</span><span class=o>,</span> <span class=k>new</span> <span class=n>Binder</span><span class=o>(){</span> 
  <span class=kd>public</span> <span class=n>Component</span> <span class=nf>bind</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>){</span> 
    <span class=k>if</span><span class=o>(((</span><span class=n>Boolean</span><span class=o>)</span><span class=n>obj</span><span class=o>).</span><span class=na>booleanValue</span><span class=o>()){</span> 
      <span class=k>return</span> <span class=n>a</span><span class=o>;</span> 
    <span class=o>}</span> 
    <span class=k>else</span> <span class=k>return</span> <span class=n>b</span><span class=o>;</span> 
  <span class=o>}</span> 
<span class=o>});</span>
</code></pre></div><p>而写成：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>c1</span><span class=o>.</span><span class=na>ifelse</span><span class=o>(</span><span class=n>a</span><span class=o>,</span><span class=n>b</span><span class=o>);</span>
</code></pre></div><p>等等等等。</p><p>这样做，从架构上确实有点损害，我们牺牲了“围绕接口”的原则，而改为围绕抽象类了。</p><p>但是，从实际效果考虑，我发现它损失的架构上的美感，远远比不上它带来的编码上的方便程度。谁让我们用的是java呢，世上没有十全十美的事情，就凑合吧。</p><p>经过这个改动，上面的对应createX的高阶代码变成：</p><p>java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Component</span> <span class=n>a_component</span> <span class=o>=</span> <span class=n>Components</span><span class=o>.</span><span class=na>static_method</span><span class=o>(</span><span class=n>A</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=s>&#34;instance&#34;</span><span class=o>);</span> 
<span class=k>return</span> <span class=n>a_component</span><span class=o>.</span><span class=na>bind</span><span class=o>(</span><span class=k>new</span> <span class=n>Binder</span><span class=o>(){</span> 
  <span class=kd>public</span> <span class=n>Component</span> <span class=nf>bind</span><span class=o>(</span><span class=kd>final</span> <span class=n>Object</span> <span class=n>a</span><span class=o>){</span> 
    <span class=kd>final</span> <span class=n>Component</span> <span class=n>isx_component</span> <span class=o>=</span> <span class=n>Components</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=s>&#34;isX&#34;</span><span class=o>);</span> 
    <span class=k>return</span> <span class=n>isx_component</span><span class=o>.</span><span class=na>ifelse</span><span class=o>(</span> 
      <span class=n>Components</span><span class=o>.</span><span class=na>ctor</span><span class=o>(</span><span class=n>X</span><span class=o>.</span><span class=na>class</span><span class=o>),</span> 
      <span class=n>Components</span><span class=o>.</span><span class=na>ctor</span><span class=o>(</span><span class=n>Y</span><span class=o>.</span><span class=na>class</span><span class=o>)</span> 
        <span class=o>.</span><span class=na>withArgument</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>Components</span><span class=o>.</span><span class=na>value</span><span class=o>(</span><span class=n>a</span><span class=o>))</span> 
        <span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=s>&#34;getX&#34;</span><span class=o>)</span> 
    <span class=o>);</span> 
  <span class=o>}</span> 
<span class=o>});</span>
</code></pre></div><p>稍微好些了。而如果我们不需要给Y的构造函数指定参数，那么效果还会更好。
比如对
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>X</span> <span class=nf>createX</span><span class=o>(){</span> 
  <span class=n>A</span> <span class=n>a</span> <span class=o>=</span> <span class=n>A</span><span class=o>.</span><span class=na>instance</span><span class=o>(...);</span> 
  <span class=k>if</span><span class=o>(</span><span class=n>a</span><span class=o>.</span><span class=na>isX</span><span class=o>(...)){</span> 
    <span class=k>return</span> <span class=k>new</span> <span class=n>X</span><span class=o>(...);</span> 
  <span class=o>}</span> 
  <span class=k>else</span><span class=o>{</span> 
    <span class=k>return</span> <span class=k>new</span> <span class=n>Y</span><span class=o>(...).</span><span class=na>getX</span><span class=o>(...);</span> 
  <span class=o>}</span> 
<span class=o>}</span>
</code></pre></div><p>高阶代码会变成：
java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Component</span> <span class=n>a_component</span> <span class=o>=</span> <span class=n>Components</span><span class=o>.</span><span class=na>static_method</span><span class=o>(</span><span class=n>A</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=s>&#34;instance&#34;</span><span class=o>);</span> 
<span class=k>return</span> <span class=n>a_component</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=s>&#34;isX&#34;</span><span class=o>).</span><span class=na>ifelse</span><span class=o>(</span> 
    <span class=n>Components</span><span class=o>.</span><span class=na>ctor</span><span class=o>(</span><span class=n>X</span><span class=o>.</span><span class=na>class</span><span class=o>),</span> 
    <span class=n>Components</span><span class=o>.</span><span class=na>ctor</span><span class=o>(</span><span class=n>Y</span><span class=o>.</span><span class=na>class</span><span class=o>)</span> 
      <span class=o>.</span><span class=na>withArgument</span><span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>Components</span><span class=o>.</span><span class=na>value</span><span class=o>(</span><span class=n>a</span><span class=o>))</span> 
      <span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=s>&#34;getX&#34;</span><span class=o>)</span> 
<span class=o>);</span> 
</code></pre></div><p>又简洁了不少。</p><p>当然，说实话，如果我们把情况任意复杂化，比如：</p><p>java代码:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Y</span> <span class=nf>createY</span><span class=o>(){</span> 
  <span class=n>a</span> <span class=o>=</span> <span class=n>A</span><span class=o>.</span><span class=na>createA</span><span class=o>(...);</span> 
  <span class=n>b</span> <span class=o>=</span> <span class=n>B</span><span class=o>.</span><span class=na>createB</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=o>...);</span> 
  <span class=n>c</span> <span class=o>=</span> <span class=n>C</span><span class=o>.</span><span class=na>createC</span><span class=o>(</span><span class=n>a</span><span class=o>,</span><span class=n>b</span><span class=o>,...);</span> 
  <span class=k>return</span> <span class=n>Y</span><span class=o>.</span><span class=na>create</span><span class=o>(</span><span class=n>a</span><span class=o>,</span><span class=n>b</span><span class=o>,</span><span class=n>c</span><span class=o>,...);</span> 
<span class=o>}</span>
</code></pre></div><p>要对createY写出高阶对应版本，这bind要嵌套三层，代码无论如何不可能好看了。对此，我们只能耸耸肩说：无能为力了。因为我们这里已经接触到了java语言的底线。</p><p>值得欣慰的是，至少：
1。对简单需求，比如pico能够处理的那些，我们的语法并不比pico麻烦。
2。对复杂需求，pico不能处理，而只能通过自己实现ComponentAdapter实现；而我们的co构建出来的系统，在没有剥夺你自己实 现Component的前提下，也提供了采用声明式的语法来组合的方式。至于是选择用熟悉的java语法来过程式地自己处理依赖，还是用声明式的高阶逻辑 来仍然让系统处理依赖，则是程序员的自由了。</p><p>我们推荐，除非对非常复杂的需求，还是用声明式的组合来处理更好。</p><p>写到这里，不得不唠叨一些语言了。就象是你也可以在c这个过程语言里面使用一些oo的技巧一样，我们在java这个oo语言里面是可以使用一些co的技巧的。</p><p>只不过，缺乏语言上的良好支持，让我们在采用co设计的时候的代价有所增大。如何权衡？是co带来的缺点（不方便调试，运行效率低，语法麻烦）大，还是它带来的好处（灵活应对变化，减少代码数量，方便重用）大，则是一个需要主观经验决定的事情了。</p><p>其实，在一个真正支持monad组合子的语言里面，createY会被类似写成这样：
java代码:</p><div class=highlight><pre class=chroma><code class=language-haskell data-lang=haskell><span class=kr>do</span> 
  <span class=n>a</span> <span class=ow>&lt;-</span> <span class=n>static_method</span><span class=p>(</span><span class=kt>A</span><span class=o>.</span><span class=kr>class</span><span class=p>,</span> <span class=s>&#34;createA&#34;</span><span class=p>);</span> 
  <span class=n>b</span> <span class=ow>&lt;-</span> <span class=n>static_method</span><span class=p>(</span><span class=kt>B</span><span class=o>.</span><span class=kr>class</span><span class=p>,</span> <span class=s>&#34;createB&#34;</span><span class=p>)</span> 
    <span class=o>.</span><span class=n>withArgument</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span> 
  <span class=n>c</span> <span class=ow>&lt;-</span> <span class=n>static_method</span><span class=p>(</span><span class=kt>C</span><span class=o>.</span><span class=kr>class</span><span class=p>,</span> <span class=s>&#34;createC&#34;</span><span class=p>)</span> 
    <span class=o>.</span><span class=n>withArgument</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>a</span><span class=p>)</span><span class=o>.</span><span class=n>withArgument</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span> 
  <span class=n>return</span> <span class=p>(</span><span class=n>static_method</span><span class=p>(</span><span class=kt>Y</span><span class=o>.</span><span class=kr>class</span><span class=p>,</span> <span class=s>&#34;create&#34;</span><span class=p>)</span> 
    <span class=o>.</span><span class=n>withArgument</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=n>a</span><span class=p>)</span><span class=o>.</span><span class=n>withArgument</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=n>b</span><span class=p>)</span><span class=o>.</span><span class=n>withArgument</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=n>c</span><span class=p>);</span> 
  <span class=p>)</span> 
</code></pre></div><p>所有的Binder匿名类会被自动生成。
这叫"do-notation&rdquo;，是haskell里面用来方便处理monad组合子的利器。</p><p>在我开发的jaskell语言里面，对do-notation有类似的支持。</p><p>题外话：
最近，看到老庄设计的DJ里面说要支持co。我觉得，如果仅仅象java这样的所谓“支持”，那就和用C的函数指针号称支持OO一样无趣了。</p><p>一个可以说得上对co有支持的语言，即使不直接支持do-notation，也应该把写匿名类的代价降到和一个lamda函数相接近的程度。
即使我不能写</p><p>java代码:</p><div class=highlight><pre class=chroma><code class=language-haskell data-lang=haskell><span class=nf>a</span> <span class=ow>&lt;-</span> <span class=n>createA</span> 
<span class=nf>b</span> <span class=ow>&lt;-</span> <span class=n>createB</span> <span class=n>a</span> 
</code></pre></div><p>也要能够写成：</p><p>java代码:</p><div class=highlight><pre class=chroma><code class=language-haskell data-lang=haskell><span class=nf>createA</span> <span class=o>&gt;&gt;=</span> <span class=nf>\</span><span class=n>a</span><span class=ow>-&gt;</span><span class=n>createB</span> <span class=n>a</span>
</code></pre></div><p>组合并不仅仅是几个简单的decorator套起来。真正复杂的co里，不同组合子之间是需要通过bind来通信的。而组合子之间的通信能力才是co强大的根源。</p></article></main><footer id=footer>Copyright © 2020 KimmyLeo</footer></body></html>